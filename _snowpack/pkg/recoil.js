import{r as Fo}from"./common/index-6302b3fe.js";import{r as te}from"./common/index-4b0af3e2.js";function Po(e){return!!e&&typeof e.then=="function"}var q=Po;function xo(e,t){if(e!=null)return e;throw new Error(t??"Got unexpected null or undefined")}var I=xo;class fn{}const Oo=new fn,Vt={valueMaybe(){},valueOrThrow(){throw new Error(`Loadable expected value, but in "${this.state}" state`)},errorMaybe(){},errorOrThrow(){throw new Error(`Loadable expected error, but in "${this.state}" state`)},promiseMaybe(){},promiseOrThrow(){throw new Error(`Loadable expected promise, but in "${this.state}" state`)},is(e){return e.state===this.state&&e.contents===this.contents},map(e){if(this.state==="hasError")return this;if(this.state==="hasValue")try{const n=e(this.contents);return q(n)?ke(n):Ct(n)}catch(n){return q(n)?ke(n.next(()=>e(this.contents))):Lt(n)}if(this.state==="loading")return ke(this.contents.then(e).catch(n=>{if(q(n))return n.then(()=>e(this.contents));throw n}));throw new Error("Invalid Loadable state")}};function Ct(e){return Object.freeze({state:"hasValue",contents:e,...Vt,getValue(){return this.contents},toPromise(){return Promise.resolve(this.contents)},valueMaybe(){return this.contents},valueOrThrow(){return this.contents}})}function Lt(e){return Object.freeze({state:"hasError",contents:e,...Vt,getValue(){throw this.contents},toPromise(){return Promise.reject(this.contents)},errorMaybe(){return this.contents},errorOrThrow(){return this.contents}})}function ke(e){return Object.freeze({state:"loading",contents:e,...Vt,getValue(){throw this.contents.then(({__value:t})=>t)},toPromise(){return this.contents.then(({__value:t})=>t)},promiseMaybe(){return this.contents.then(({__value:t})=>t)},promiseOrThrow(){return this.contents.then(({__value:t})=>t)}})}function zo(){return ke(new Promise(()=>{}))}function Wo(e){return e.every(t=>t.state==="hasValue")?Ct(e.map(t=>t.contents)):e.some(t=>t.state==="hasError")?Lt(I(e.find(t=>t.state==="hasError"),"Invalid loadable passed to loadableAll").contents):ke(Promise.all(e.map(t=>t.contents)).then(t=>({__value:t})))}var nt={loadableWithValue:Ct,loadableWithError:Lt,loadableWithPromise:ke,loadableLoading:zo,loadableAll:Wo,Canceled:fn,CANCELED:Oo};function Go(e,t,{error:n}={}){return null}var Ho=Go,Ko=Ho;function qo(e,t){const n=new Set(e);return n.add(t),n}function Zo(e,t){const n=new Set(e);return n.delete(t),n}function jo(e,t,n){const o=new Map(e);return o.set(t,n),o}function Xo(e,t,n){const o=new Map(e);return o.set(t,n(o.get(t))),o}function Yo(e,t){const n=new Map(e);return n.delete(t),n}function Jo(e,t){const n=new Map(e);return t.forEach(o=>n.delete(o)),n}var dn={setByAddingToSet:qo,setByDeletingFromSet:Zo,mapBySettingInMap:jo,mapByUpdatingInMap:Xo,mapByDeletingFromMap:Yo,mapByDeletingMultipleFromMap:Jo};function*Qo(e,t){let n=0;for(const o of e)t(o,n++)&&(yield o)}var hn=Qo;const $t=new Map().set("recoil_hamt_2020",!0).set("recoil_memory_managament_2020",!0);function Mt(e){var t;return(t=$t.get(e))!==null&&t!==void 0?t:!1}Mt.setPass=e=>{$t.set(e,!0)},Mt.setFail=e=>{$t.set(e,!1)};var G=Mt;function er(e,t){return function*(){let n=0;for(const o of e)yield t(o,n++)}()}var pn=er;function x(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}class Dt{constructor(t){x(this,"key",void 0),this.key=t}}class vn extends Dt{}class _n extends Dt{}function tr(e){return e instanceof vn||e instanceof _n}var ot={AbstractRecoilValue:Dt,RecoilState:vn,RecoilValueReadOnly:_n,isRecoilValue:tr},nr=ot.AbstractRecoilValue,or=ot.RecoilState,rr=ot.RecoilValueReadOnly,ar=ot.isRecoilValue,Le=Object.freeze({__proto__:null,AbstractRecoilValue:nr,RecoilState:or,RecoilValueReadOnly:rr,isRecoilValue:ar});class mn{}const sr=new mn;class ir extends Error{constructor(t){super(`Tried to set the value of Recoil selector ${t} using an updater function, but it is an async selector in a pending or error state; this is not supported.`)}}const $e=new Map,kt=new Map;function cr(e){return pn(e,t=>I(kt.get(t)))}function lr(e){if($e.has(e.key)){const n=`Duplicate atom key "${e.key}". This is a FATAL ERROR in
      production. But it is safe to ignore this warning if it occurred because of
      hot module replacement.`;console.warn(n)}$e.set(e.key,e);const t=e.set==null?new Le.RecoilValueReadOnly(e.key):new Le.RecoilState(e.key);return kt.set(e.key,t),t}class yn extends Error{}function ur(e){const t=$e.get(e);if(t==null)throw new yn(`Missing definition for RecoilValue: "${e}""`);return t}function fr(e){return $e.get(e)}const rt=new Map;function dr(e){var t;if(!G("recoil_memory_managament_2020"))return;const n=$e.get(e);if(n==null||(t=n.shouldDeleteConfigOnRelease)===null||t===void 0?void 0:t.call(n)){var o;$e.delete(e),(o=Sn(e))===null||o===void 0||o(),rt.delete(e)}}function hr(e,t){!G("recoil_memory_managament_2020")||(t===void 0?rt.delete(e):rt.set(e,t))}function Sn(e){return rt.get(e)}var pe={nodes:$e,recoilValues:kt,registerNode:lr,getNode:ur,getNodeMaybe:fr,deleteNodeConfigIfPossible:dr,setConfigDeletionHandler:hr,getConfigDeletionHandler:Sn,recoilValuesForKeys:cr,NodeMissingError:yn,DefaultValue:mn,DEFAULT_VALUE:sr,RecoilValueNotReady:ir};class Rn{}function pr(){return new Rn}var at={RetentionZone:Rn,retentionZone:pr};const{setByAddingToSet:vr}=dn,{getNode:st,getNodeMaybe:_r,recoilValuesForKeys:gn}=pe,{RetentionZone:bn}=at,mr=Object.freeze(new Set);class yr extends Error{}function Sr(e,t,n){if(!G("recoil_memory_managament_2020"))return()=>{};const{nodesRetainedByZone:o}=e.getState().retention;function r(a){let i=o.get(a);i||o.set(a,i=new Set),i.add(t)}if(n instanceof bn)r(n);else if(Array.isArray(n))for(const a of n)r(a);return()=>{if(!G("recoil_memory_managament_2020"))return;const a=e.getState().retention.nodesRetainedByZone;function i(l){const f=a.get(l);f&&f.delete(t),f&&f.size===0&&a.delete(l)}if(n instanceof bn)i(n);else if(Array.isArray(n))for(const l of n)i(l)}}function Ut(e,t,n,o){const r=e.getState();if(r.nodeCleanupFunctions.has(n))return;const a=st(n),i=Sr(e,n,a.retainedBy),l=a.init(e,t,o);r.nodeCleanupFunctions.set(n,()=>{l(),i()})}function Rr(e,t){var n;const o=e.getState();(n=o.nodeCleanupFunctions.get(t))===null||n===void 0||n(),o.nodeCleanupFunctions.delete(t)}function gr(e,t,n){return Ut(e,t,n,"get"),st(n).get(e,t)}function wn(e,t,n){return st(n).peek(e,t)}function br(e,t,n){var o;const r=_r(t);return r==null||(o=r.invalidate)===null||o===void 0||o.call(r,e),{...e,atomValues:e.atomValues.clone().delete(t),nonvalidatedAtoms:e.nonvalidatedAtoms.clone().set(t,n),dirtyAtoms:vr(e.dirtyAtoms,t)}}function wr(e,t,n,o){const r=st(n);if(r.set==null)throw new yr(`Attempt to set read-only RecoilValue: ${n}`);const a=r.set;return Ut(e,t,n,"set"),a(e,t,o)}function Tr(e,t,n){var o,r,a;const i=e.getState(),l=e.getGraph(t.version),f=i.knownAtoms.has(n)?"atom":i.knownSelectors.has(n)?"selector":void 0,h=hn(Tn(e,t,new Set([n])),p=>p!==n);return{loadable:wn(e,t,n),isActive:i.knownAtoms.has(n)||i.knownSelectors.has(n),isSet:f==="selector"?!1:t.atomValues.has(n),isModified:t.dirtyAtoms.has(n),type:f,deps:gn((o=l.nodeDeps.get(n))!==null&&o!==void 0?o:[]),subscribers:{nodes:gn(h),components:pn((r=(a=i.nodeToComponentSubscriptions.get(n))===null||a===void 0?void 0:a.values())!==null&&r!==void 0?r:[],([p])=>({name:p}))}}}function Tn(e,t,n){const o=new Set,r=Array.from(n),a=e.getGraph(t.version);for(let l=r.pop();l;l=r.pop()){var i;o.add(l);const f=(i=a.nodeToNodeSubscriptions.get(l))!==null&&i!==void 0?i:mr;for(const h of f)o.has(h)||r.push(h)}return o}var Ue={getNodeLoadable:gr,peekNodeLoadable:wn,setNodeValue:wr,cleanUpNode:Rr,setUnvalidatedAtomValue_DEPRECATED:br,peekNodeInfo:Tr,getDownstreamNodes:Tn,initializeNodeIfNewToStore:Ut};const{CANCELED:Ar}=nt,{getDownstreamNodes:Er,getNodeLoadable:An,setNodeValue:Nr}=Ue,{getNodeMaybe:En}=pe,{DefaultValue:It,RecoilValueNotReady:Vr}=pe,{AbstractRecoilValue:Cr,RecoilState:Lr,RecoilValueReadOnly:$r,isRecoilValue:Mr}=Le;function Dr(e,{key:t},n=e.getState().currentTree){var o,r;const a=e.getState();!(n.version===a.currentTree.version||n.version===((o=a.nextTree)===null||o===void 0?void 0:o.version)||n.version===((r=a.previousTree)===null||r===void 0?void 0:r.version));const i=An(e,n,t);return i.state==="loading"&&i.contents.catch(()=>Ar),i}function kr(e,t){const n=e.clone();return t.forEach((o,r)=>{o.state==="hasValue"&&o.contents instanceof It?n.delete(r):n.set(r,o)}),n}function Ur(e,t,{key:n},o){if(typeof o=="function"){const r=An(e,t,n);if(r.state==="loading")throw new Vr(n);if(r.state==="hasError")throw r.contents;return o(r.contents)}else return o}function Ir(e,t,n){if(n.type==="set"){const{recoilValue:r,valueOrUpdater:a}=n,i=Ur(e,t,r,a),l=Nr(e,t,r.key,i);for(const[f,h]of l.entries())Nn(t,f,h)}else if(n.type==="setLoadable"){const{recoilValue:{key:r},loadable:a}=n;Nn(t,r,a)}else if(n.type==="markModified"){const{recoilValue:{key:r}}=n;t.dirtyAtoms.add(r)}else if(n.type==="setUnvalidated"){var o;const{recoilValue:{key:r},unvalidatedValue:a}=n,i=En(r);i==null||(o=i.invalidate)===null||o===void 0||o.call(i,t),t.atomValues.delete(r),t.nonvalidatedAtoms.set(r,a),t.dirtyAtoms.add(r)}else Ko(`Unknown action ${n.type}`)}function Nn(e,t,n){n.state==="hasValue"&&n.contents instanceof It?e.atomValues.delete(t):e.atomValues.set(t,n),e.dirtyAtoms.add(t),e.nonvalidatedAtoms.delete(t)}function Vn(e,t){e.replaceState(n=>{const o=Fr(n);for(const r of t)Ir(e,o,r);return Cn(e,o),o})}function it(e,t){if(We.length){const n=We[We.length-1];let o=n.get(e);o||n.set(e,o=[]),o.push(t)}else Vn(e,[t])}const We=[];function Br(){const e=new Map;return We.push(e),()=>{for(const[n,o]of e)Vn(n,o);const t=We.pop()}}function Fr(e){return{...e,atomValues:e.atomValues.clone(),nonvalidatedAtoms:e.nonvalidatedAtoms.clone(),dirtyAtoms:new Set(e.dirtyAtoms)}}function Cn(e,t){const n=Er(e,t,t.dirtyAtoms);for(const a of n){var o,r;(o=En(a))===null||o===void 0||(r=o.invalidate)===null||r===void 0||r.call(o,t)}}function Ln(e,t,n){it(e,{type:"set",recoilValue:t,valueOrUpdater:n})}function Pr(e,t,n){if(n instanceof It)return Ln(e,t,n);it(e,{type:"setLoadable",recoilValue:t,loadable:n})}function xr(e,t){it(e,{type:"markModified",recoilValue:t})}function Or(e,t,n){it(e,{type:"setUnvalidated",recoilValue:t,unvalidatedValue:n})}let zr=0;function Wr(e,{key:t},n,o=null){const r=zr++,a=e.getState();return a.nodeToComponentSubscriptions.has(t)||a.nodeToComponentSubscriptions.set(t,new Map),I(a.nodeToComponentSubscriptions.get(t)).set(r,[o??"<not captured>",n]),{release:()=>{const i=e.getState(),l=i.nodeToComponentSubscriptions.get(t);l===void 0||!l.has(r)||(l.delete(r),l.size===0&&i.nodeToComponentSubscriptions.delete(t))}}}var Ie={RecoilValueReadOnly:$r,AbstractRecoilValue:Cr,RecoilState:Lr,getRecoilValueAsLoadable:Dr,setRecoilValue:Ln,setRecoilValueLoadable:Pr,markRecoilValueModified:xr,setUnvalidatedRecoilValue:Or,subscribeToRecoilValue:Wr,isRecoilValue:Mr,applyAtomValueWrites:kr,batchStart:Br,invalidateDownstreams_FOR_TESTING:Cn};const{unstable_batchedUpdates:Gr}=Fo;var Hr={unstable_batchedUpdates:Gr};const{unstable_batchedUpdates:Kr}=Hr;var qr={unstable_batchedUpdates:Kr};const{batchStart:Zr}=Ie,{unstable_batchedUpdates:jr}=qr;let Bt=jr;const Xr=e=>{Bt=e},Yr=()=>Bt,Jr=e=>{Bt(()=>{let t=()=>{};try{t=Zr(),e()}finally{t()}})};var Ft={getBatcher:Yr,setBatcher:Xr,batchUpdates:Jr};function Qr(e,t){t()}var ea={enqueueExecution:Qr};function ta(e,...t){const n=new Set;e:for(const o of e){for(const r of t)if(r.has(o))continue e;n.add(o)}return n}var ct=ta;function na(e,t){const n=new Map;return e.forEach((o,r)=>{n.set(r,t(o,r))}),n}var lt=na;function oa(){return{nodeDeps:new Map,nodeToNodeSubscriptions:new Map}}function ra(e){return{nodeDeps:lt(e.nodeDeps,t=>new Set(t)),nodeToNodeSubscriptions:lt(e.nodeToNodeSubscriptions,t=>new Set(t))}}function Pt(e,t,n){const{nodeDeps:o,nodeToNodeSubscriptions:r}=t;e.forEach((a,i)=>{const l=o.get(i);if(l&&n&&l!==n.nodeDeps.get(i))return;o.set(i,new Set(a)),(l==null?a:ct(a,l)).forEach(h=>{r.has(h)||r.set(h,new Set),I(r.get(h)).add(i)}),l&&ct(l,a).forEach(p=>{if(!r.has(p))return;const T=I(r.get(p));T.delete(i),T.size===0&&r.delete(p)})})}function aa(e,t,n){var o,r,a,i;const l=t.getState();!(n===l.currentTree.version||n===((o=l.nextTree)===null||o===void 0?void 0:o.version)||n===((r=l.previousTree)===null||r===void 0?void 0:r.version));const f=t.getGraph(n);if(Pt(e,f),n===((a=l.previousTree)===null||a===void 0?void 0:a.version)){const p=t.getGraph(l.currentTree.version);Pt(e,p,f)}if(n===((i=l.previousTree)===null||i===void 0?void 0:i.version)||n===l.currentTree.version){var h;const p=(h=l.nextTree)===null||h===void 0?void 0:h.version;if(p!==void 0){const T=t.getGraph(p);Pt(e,T,f)}}}function sa(e,t){e.forEach((n,o)=>{t.has(o)||t.set(o,new Set);const r=I(t.get(o));n.forEach(a=>r.add(a))})}function ia(e,t,n){n.has(e)||n.set(e,new Set),I(n.get(e)).add(t)}var Ge={addToDependencyMap:ia,cloneGraph:ra,graph:oa,mergeDepsIntoDependencyMap:sa,saveDependencyMapToStore:aa};function ca(e,t){return t={exports:{}},e(t,t.exports),t.exports}var la=ca(function(e){var t=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(c){return typeof c}:function(c){return c&&typeof Symbol=="function"&&c.constructor===Symbol&&c!==Symbol.prototype?"symbol":typeof c},n={},o=5,r=Math.pow(2,o),a=r-1,i=r/2,l=r/4,f={},h=function(s){return function(){return s}},p=n.hash=function(c){var s=typeof c=="undefined"?"undefined":t(c);if(s==="number")return c;s!=="string"&&(c+="");for(var d=0,_=0,m=c.length;_<m;++_){var R=c.charCodeAt(_);d=(d<<5)-d+R|0}return d},T=function(s){return s-=s>>1&1431655765,s=(s&858993459)+(s>>2&858993459),s=s+(s>>4)&252645135,s+=s>>8,s+=s>>16,s&127},U=function(s,d){return d>>>s&a},F=function(s){return 1<<s},A=function(s,d){return T(s&d-1)},B=function(s,d,_,m){var R=m;if(!s){var V=m.length;R=new Array(V);for(var E=0;E<V;++E)R[E]=m[E]}return R[d]=_,R},b=function(s,d,_){var m=_.length-1,R=0,V=0,E=_;if(s)R=V=d;else for(E=new Array(m);R<d;)E[V++]=_[R++];for(++R;R<=m;)E[V++]=_[R++];return s&&(E.length=m),E},D=function(s,d,_,m){var R=m.length;if(s){for(var V=R;V>=d;)m[V--]=m[V];return m[d]=_,m}for(var E=0,N=0,M=new Array(R+1);E<d;)M[N++]=m[E++];for(M[d]=_;E<R;)M[++N]=m[E++];return M},C=1,L=2,k=3,H=4,Y={__hamt_isEmpty:!0},X=function(s){return s===Y||s&&s.__hamt_isEmpty},K=function(s,d,_,m){return{type:C,edit:s,hash:d,key:_,value:m,_modify:ye}},ce=function(s,d,_){return{type:L,edit:s,hash:d,children:_,_modify:Ne}},be=function(s,d,_){return{type:k,edit:s,mask:d,children:_,_modify:le}},we=function(s,d,_){return{type:H,edit:s,size:d,children:_,_modify:Ve}},ee=function(s){return s===Y||s.type===C||s.type===L},Z=function(s,d,_,m,R){for(var V=[],E=m,N=0,M=0;E;++M)E&1&&(V[M]=R[N++]),E>>>=1;return V[d]=_,we(s,N+1,V)},Se=function(s,d,_,m){for(var R=new Array(d-1),V=0,E=0,N=0,M=m.length;N<M;++N)if(N!==_){var z=m[N];z&&!X(z)&&(R[V++]=z,E|=1<<N)}return be(s,E,R)},re=function c(s,d,_,m,R,V){if(_===R)return ce(s,_,[V,m]);var E=U(d,_),N=U(d,R);return be(s,F(E)|F(N),E===N?[c(s,d+o,_,m,R,V)]:E<N?[m,V]:[V,m])},me=function(s,d,_,m,R,V,E,N){for(var M=R.length,z=0;z<M;++z){var ae=R[z];if(_(E,ae.key)){var Q=ae.value,se=V(Q);return se===Q?R:se===f?(--N.value,b(s,z,R)):B(s,z,K(d,m,E,se),R)}}var he=V();return he===f?R:(++N.value,B(s,M,K(d,m,E,he),R))},ne=function(s,d){return s===d.edit},ye=function(s,d,_,m,R,V,E){if(d(V,this.key)){var N=m(this.value);return N===this.value?this:N===f?(--E.value,Y):ne(s,this)?(this.value=N,this):K(s,R,V,N)}var M=m();return M===f?this:(++E.value,re(s,_,this.hash,this,R,K(s,R,V,M)))},Ne=function(s,d,_,m,R,V,E){if(R===this.hash){var N=ne(s,this),M=me(N,s,d,this.hash,this.children,m,V,E);return M===this.children?this:M.length>1?ce(s,this.hash,M):M[0]}var z=m();return z===f?this:(++E.value,re(s,_,this.hash,this,R,K(s,R,V,z)))},le=function(s,d,_,m,R,V,E){var N=this.mask,M=this.children,z=U(_,R),ae=F(z),Q=A(N,ae),se=N&ae,he=se?M[Q]:Y,De=he._modify(s,d,_+o,m,R,V,E);if(he===De)return this;var tt=ne(s,this),Oe=N,ze=void 0;if(se&&X(De)){if(Oe&=~ae,!Oe)return Y;if(M.length<=2&&ee(M[Q^1]))return M[Q^1];ze=b(tt,Q,M)}else if(!se&&!X(De)){if(M.length>=i)return Z(s,z,De,N,M);Oe|=ae,ze=D(tt,Q,De,M)}else ze=B(tt,Q,De,M);return tt?(this.mask=Oe,this.children=ze,this):be(s,Oe,ze)},Ve=function(s,d,_,m,R,V,E){var N=this.size,M=this.children,z=U(_,R),ae=M[z],Q=(ae||Y)._modify(s,d,_+o,m,R,V,E);if(ae===Q)return this;var se=ne(s,this),he=void 0;if(X(ae)&&!X(Q))++N,he=B(se,z,Q,M);else if(!X(ae)&&X(Q)){if(--N,N<=l)return Se(s,N,z,M);he=B(se,z,Y,M)}else he=B(se,z,Q,M);return se?(this.size=N,this.children=he,this):we(s,N,he)};Y._modify=function(c,s,d,_,m,R,V){var E=_();return E===f?Y:(++V.value,K(c,m,R,E))};function $(c,s,d,_,m){this._editable=c,this._edit=s,this._config=d,this._root=_,this._size=m}$.prototype.setTree=function(c,s){return this._editable?(this._root=c,this._size=s,this):c===this._root?this:new $(this._editable,this._edit,this._config,c,s)};var ue=n.tryGetHash=function(c,s,d,_){for(var m=_._root,R=0,V=_._config.keyEq;;)switch(m.type){case C:return V(d,m.key)?m.value:c;case L:{if(s===m.hash)for(var E=m.children,N=0,M=E.length;N<M;++N){var z=E[N];if(V(d,z.key))return z.value}return c}case k:{var ae=U(R,s),Q=F(ae);if(m.mask&Q){m=m.children[A(m.mask,Q)],R+=o;break}return c}case H:{if(m=m.children[U(R,s)],m){R+=o;break}return c}default:return c}};$.prototype.tryGetHash=function(c,s,d){return ue(c,s,d,this)};var Ce=n.tryGet=function(c,s,d){return ue(c,d._config.hash(s),s,d)};$.prototype.tryGet=function(c,s){return Ce(c,s,this)};var u=n.getHash=function(c,s,d){return ue(void 0,c,s,d)};$.prototype.getHash=function(c,s){return u(c,s,this)};var y=n.get=function(c,s){return ue(void 0,s._config.hash(c),c,s)};$.prototype.get=function(c,s){return Ce(s,c,this)};var v=n.has=function(c,s,d){return ue(f,c,s,d)!==f};$.prototype.hasHash=function(c,s){return v(c,s,this)};var w=n.has=function(c,s){return v(s._config.hash(c),c,s)};$.prototype.has=function(c){return w(c,this)};var g=function(s,d){return s===d};n.make=function(c){return new $(0,0,{keyEq:c&&c.keyEq||g,hash:c&&c.hash||p},Y,0)},n.empty=n.make();var S=n.isEmpty=function(c){return c&&!!X(c._root)};$.prototype.isEmpty=function(){return S(this)};var P=n.modifyHash=function(c,s,d,_){var m={value:_._size},R=_._root._modify(_._editable?_._edit:NaN,_._config.keyEq,0,c,s,d,m);return _.setTree(R,m.value)};$.prototype.modifyHash=function(c,s,d){return P(d,c,s,this)};var J=n.modify=function(c,s,d){return P(c,d._config.hash(s),s,d)};$.prototype.modify=function(c,s){return J(s,c,this)};var j=n.setHash=function(c,s,d,_){return P(h(d),c,s,_)};$.prototype.setHash=function(c,s,d){return j(c,s,d,this)};var O=n.set=function(c,s,d){return j(d._config.hash(c),c,s,d)};$.prototype.set=function(c,s){return O(c,s,this)};var W=h(f),oe=n.removeHash=function(c,s,d){return P(W,c,s,d)};$.prototype.removeHash=$.prototype.deleteHash=function(c,s){return oe(c,s,this)};var xe=n.remove=function(c,s){return oe(s._config.hash(c),c,s)};$.prototype.remove=$.prototype.delete=function(c){return xe(c,this)};var Re=n.beginMutation=function(c){return new $(c._editable+1,c._edit+1,c._config,c._root,c._size)};$.prototype.beginMutation=function(){return Re(this)};var fe=n.endMutation=function(c){return c._editable=c._editable&&c._editable-1,c};$.prototype.endMutation=function(){return fe(this)};var de=n.mutate=function(c,s){var d=Re(s);return c(d),fe(d)};$.prototype.mutate=function(c){return de(c,this)};var Me=function(s){return s&&cn(s[0],s[1],s[2],s[3],s[4])},cn=function(s,d,_,m,R){for(;_<s;){var V=d[_++];if(V&&!X(V))return ln(V,m,[s,d,_,m,R])}return Me(R)},ln=function(s,d,_){switch(s.type){case C:return{value:d(s),rest:_};case L:case H:case k:var m=s.children;return cn(m.length,m,0,d,_);default:return Me(_)}},Co={done:!0};function Et(c){this.v=c}Et.prototype.next=function(){if(!this.v)return Co;var c=this.v;return this.v=Me(c.rest),c},Et.prototype[Symbol.iterator]=function(){return this};var Nt=function(s,d){return new Et(ln(s._root,d))},Lo=function(s){return[s.key,s.value]},$o=n.entries=function(c){return Nt(c,Lo)};$.prototype.entries=$.prototype[Symbol.iterator]=function(){return $o(this)};var Mo=function(s){return s.key},Do=n.keys=function(c){return Nt(c,Mo)};$.prototype.keys=function(){return Do(this)};var ko=function(s){return s.value},Uo=n.values=$.prototype.values=function(c){return Nt(c,ko)};$.prototype.values=function(){return Uo(this)};var un=n.fold=function(c,s,d){var _=d._root;if(_.type===C)return c(s,_.value,_.key);for(var m=[_.children],R=void 0;R=m.pop();)for(var V=0,E=R.length;V<E;){var N=R[V++];N&&N.type&&(N.type===C?s=c(s,N.value,N.key):m.push(N.children))}return s};$.prototype.fold=function(c,s){return un(c,s,this)};var Io=n.forEach=function(c,s){return un(function(d,_,m){return c(_,m,s)},null,s)};$.prototype.forEach=function(c){return Io(c,this)};var Bo=n.count=function(c){return c._size};$.prototype.count=function(){return Bo(this)},Object.defineProperty($.prototype,"size",{get:$.prototype.count}),e.exports?e.exports=n:(void 0).hamt=n});class ua{constructor(t){x(this,"_map",void 0),this._map=new Map(t==null?void 0:t.entries())}keys(){return this._map.keys()}entries(){return this._map.entries()}get(t){return this._map.get(t)}has(t){return this._map.has(t)}set(t,n){return this._map.set(t,n),this}delete(t){return this._map.delete(t),this}clone(){return Ot(this)}toMap(){return new Map(this._map)}}class xt{constructor(t){if(x(this,"_hamt",la.empty.beginMutation()),t instanceof xt){const n=t._hamt.endMutation();t._hamt=n.beginMutation(),this._hamt=n.beginMutation()}else if(t)for(const[n,o]of t.entries())this._hamt.set(n,o)}keys(){return this._hamt.keys()}entries(){return this._hamt.entries()}get(t){return this._hamt.get(t)}has(t){return this._hamt.has(t)}set(t,n){return this._hamt.set(t,n),this}delete(t){return this._hamt.delete(t),this}clone(){return Ot(this)}toMap(){return new Map(this._hamt)}}function Ot(e){return G("recoil_hamt_2020")?new xt(e):new ua(e)}var fa={persistentMap:Ot},da=fa.persistentMap,ha=Object.freeze({__proto__:null,persistentMap:da});const{graph:pa}=Ge,{persistentMap:$n}=ha;let va=0;const Mn=()=>va++;function Dn(){const e=Mn();return{version:e,stateID:e,transactionMetadata:{},dirtyAtoms:new Set,atomValues:$n(),nonvalidatedAtoms:$n()}}function _a(){const e=Dn();return{currentTree:e,nextTree:null,previousTree:null,commitDepth:0,knownAtoms:new Set,knownSelectors:new Set,transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:new Map().set(e.version,pa()),versionsUsedByComponent:new Map,retention:{referenceCounts:new Map,nodesRetainedByZone:new Map,retainablesToCheckForRelease:new Set},nodeCleanupFunctions:new Map}}var kn={makeEmptyTreeState:Dn,makeEmptyStoreState:_a,getNextTreeStateVersion:Mn};function ma(...e){const t=new Set;for(const n of e)for(const o of n)t.add(o);return t}var ya=ma;function Sa(e,t,n){const o=e.entries();let r=o.next();for(;!r.done;){const a=r.value;if(t.call(n,a[1],a[0],e))return!0;r=o.next()}return!1}var Ra=Sa;const{cleanUpNode:ga}=Ue,{deleteNodeConfigIfPossible:ba,getNode:Un}=pe,{RetentionZone:In}=at,Bn=new Set;function Fn(e,t){const n=e.getState(),o=n.currentTree;if(n.nextTree)return;const r=new Set;for(const i of t)if(i instanceof In)for(const l of Ea(n,i))r.add(l);else r.add(i);const a=wa(e,r);for(const i of a)Aa(e,o,i)}function wa(e,t){const n=e.getState(),o=n.currentTree,r=e.getGraph(o.version),a=new Set,i=new Set;return l(t),a;function l(f){const h=new Set,p=Ta(e,o,f,a,i);for(const A of p){var T;if(Un(A).retainedBy==="recoilRoot"){i.add(A);continue}if(((T=n.retention.referenceCounts.get(A))!==null&&T!==void 0?T:0)>0){i.add(A);continue}if(Pn(A).some(b=>n.retention.referenceCounts.get(b))){i.add(A);continue}const B=r.nodeToNodeSubscriptions.get(A);if(B&&Ra(B,b=>i.has(b))){i.add(A);continue}a.add(A),h.add(A)}const U=new Set;for(const A of h)for(const B of(F=r.nodeDeps.get(A))!==null&&F!==void 0?F:Bn){var F;a.has(B)||U.add(B)}U.size&&l(U)}}function Ta(e,t,n,o,r){const a=e.getGraph(t.version),i=[],l=new Set;for(;n.size>0;)f(I(n.values().next().value));return i;function f(h){if(o.has(h)||r.has(h)){n.delete(h);return}if(l.has(h))return;const p=a.nodeToNodeSubscriptions.get(h);if(p)for(const T of p)f(T);l.add(h),n.delete(h),i.push(h)}}function Aa(e,t,n){if(!G("recoil_memory_managament_2020"))return;ga(e,n);const o=e.getState();o.knownAtoms.delete(n),o.knownSelectors.delete(n),o.nodeTransactionSubscriptions.delete(n),o.retention.referenceCounts.delete(n);const r=Pn(n);for(const f of r){var a;(a=o.retention.nodesRetainedByZone.get(f))===null||a===void 0||a.delete(n)}t.atomValues.delete(n),t.dirtyAtoms.delete(n),t.nonvalidatedAtoms.delete(n);const i=o.graphsByVersion.get(t.version);if(i){const f=i.nodeDeps.get(n);if(f!==void 0){i.nodeDeps.delete(n);for(const h of f){var l;(l=i.nodeToNodeSubscriptions.get(h))===null||l===void 0||l.delete(n)}}i.nodeToNodeSubscriptions.delete(n)}ba(n)}function Ea(e,t){var n;return(n=e.retention.nodesRetainedByZone.get(t))!==null&&n!==void 0?n:Bn}function Pn(e){const t=Un(e).retainedBy;return t===void 0||t==="components"||t==="recoilRoot"?[]:t instanceof In?[t]:t}function Na(e,t){const n=e.getState();n.nextTree?n.retention.retainablesToCheckForRelease.add(t):Fn(e,new Set([t]))}function Va(e,t,n){var o;if(!G("recoil_memory_managament_2020"))return;const r=e.getState().retention.referenceCounts,a=((o=r.get(t))!==null&&o!==void 0?o:0)+n;a===0?xn(e,t):r.set(t,a)}function xn(e,t){if(!G("recoil_memory_managament_2020"))return;e.getState().retention.referenceCounts.delete(t),Na(e,t)}function Ca(e){if(!G("recoil_memory_managament_2020"))return;const t=e.getState();Fn(e,t.retention.retainablesToCheckForRelease),t.retention.retainablesToCheckForRelease.clear()}function La(e){return e===void 0?"recoilRoot":e}var He={updateRetainCount:Va,updateRetainCountToZero:xn,releaseScheduledRetainablesNow:Ca,retainedByOptionWithDefault:La};function*$a(e){for(const t of e)for(const n of t)yield n}var Ma=$a;const Da=typeof window=="undefined",ka=typeof navigator!="undefined"&&navigator.product==="ReactNative";var On={isSSR:Da,isReactNative:ka};const{isSSR:Ua}=On,{batchUpdates:zt}=Ft,{initializeNodeIfNewToStore:Ia,peekNodeInfo:Ba}=Ue,{graph:Fa}=Ge,{DEFAULT_VALUE:Pa,recoilValues:zn,recoilValuesForKeys:Wn}=pe,{AbstractRecoilValue:xa,getRecoilValueAsLoadable:Oa,setRecoilValue:Gn,setUnvalidatedRecoilValue:za}=Ie,{updateRetainCount:ut,updateRetainCountToZero:sl}=He,{getNextTreeStateVersion:Wa,makeEmptyStoreState:Ga}=kn;class ft{constructor(t){x(this,"_store",void 0),x(this,"_refCount",0),x(this,"getLoadable",n=>(this.checkRefCount_INTERNAL(),Oa(this._store,n))),x(this,"getPromise",n=>(this.checkRefCount_INTERNAL(),this.getLoadable(n).toPromise())),x(this,"getNodes_UNSTABLE",n=>{if(this.checkRefCount_INTERNAL(),(n==null?void 0:n.isModified)===!0){if((n==null?void 0:n.isInitialized)===!1)return[];const a=this._store.getState().currentTree;return Wn(a.dirtyAtoms)}const o=this._store.getState().knownAtoms,r=this._store.getState().knownSelectors;return(n==null?void 0:n.isInitialized)==null?zn.values():n.isInitialized===!0?Wn(Ma([this._store.getState().knownAtoms,this._store.getState().knownSelectors])):hn(zn.values(),({key:a})=>!o.has(a)&&!r.has(a))}),x(this,"getInfo_UNSTABLE",({key:n})=>(this.checkRefCount_INTERNAL(),Ba(this._store,this._store.getState().currentTree,n))),x(this,"map",n=>{this.checkRefCount_INTERNAL();const o=new Gt(this);return n(o),Wt(o.getStore_INTERNAL())}),x(this,"asyncMap",async n=>{this.checkRefCount_INTERNAL();const o=new Gt(this);return await n(o),Wt(o.getStore_INTERNAL())}),this._store={getState:()=>t,replaceState:n=>{t.currentTree=n(t.currentTree)},getGraph:n=>{const o=t.graphsByVersion;if(o.has(n))return I(o.get(n));const r=Fa();return o.set(n,r),r},subscribeToTransactions:()=>({release:()=>{}}),addTransactionMetadata:()=>{throw new Error("Cannot subscribe to Snapshots")}};for(const n of this._store.getState().nodeCleanupFunctions.keys())Ia(this._store,t.currentTree,n,"get"),ut(this._store,n,1);this.retain(),this.autorelease_INTERNAL()}retain(){if(!G("recoil_memory_managament_2020"))return()=>{};this._refCount++;let t=!1;return()=>{t||(t=!0,this.release_INTERNAL())}}autorelease_INTERNAL(){!G("recoil_memory_managament_2020")||Ua||window.setTimeout(()=>this.release_INTERNAL(),0)}release_INTERNAL(){!G("recoil_memory_managament_2020")||(this._refCount--,this._refCount===0)}checkRefCount_INTERNAL(){G("recoil_memory_managament_2020")&&this._refCount<=0}getStore_INTERNAL(){return this.checkRefCount_INTERNAL(),this._store}getID(){return this.checkRefCount_INTERNAL(),this.getID_INTERNAL()}getID_INTERNAL(){return this.checkRefCount_INTERNAL(),this._store.getState().currentTree.stateID}}function Hn(e,t,n=!1){const o=e.getState(),r=n?Wa():t.version;return{currentTree:n?{version:r,stateID:r,transactionMetadata:{...t.transactionMetadata},dirtyAtoms:new Set(t.dirtyAtoms),atomValues:t.atomValues.clone(),nonvalidatedAtoms:t.nonvalidatedAtoms.clone()}:t,commitDepth:0,nextTree:null,previousTree:null,knownAtoms:new Set(o.knownAtoms),knownSelectors:new Set(o.knownSelectors),transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:new Map().set(r,e.getGraph(t.version)),versionsUsedByComponent:new Map,retention:{referenceCounts:new Map,nodesRetainedByZone:new Map,retainablesToCheckForRelease:new Set},nodeCleanupFunctions:new Map}}function Ha(e){const t=new ft(Ga());return e!=null?t.map(e):t}function Wt(e,t="current"){const n=e.getState(),o=t==="current"?n.currentTree:I(n.previousTree);return new ft(Hn(e,o))}class Gt extends ft{constructor(t){super(Hn(t.getStore_INTERNAL(),t.getStore_INTERNAL().getState().currentTree,!0));x(this,"set",(n,o)=>{this.checkRefCount_INTERNAL();const r=this.getStore_INTERNAL();zt(()=>{ut(r,n.key,1),Gn(this.getStore_INTERNAL(),n,o)})}),x(this,"reset",n=>{this.checkRefCount_INTERNAL();const o=this.getStore_INTERNAL();zt(()=>{ut(o,n.key,1),Gn(this.getStore_INTERNAL(),n,Pa)})}),x(this,"setUnvalidatedAtomValues_DEPRECATED",n=>{this.checkRefCount_INTERNAL();const o=this.getStore_INTERNAL();zt(()=>{for(const[r,a]of n.entries())ut(o,r,1),za(o,new xa(r),a)})})}}var dt={Snapshot:ft,MutableSnapshot:Gt,freshSnapshot:Ha,cloneSnapshot:Wt},Ka=dt.Snapshot,qa=dt.MutableSnapshot,Za=dt.freshSnapshot,ja=dt.cloneSnapshot,ht=Object.freeze({__proto__:null,Snapshot:Ka,MutableSnapshot:qa,freshSnapshot:Za,cloneSnapshot:ja});const{getNextTreeStateVersion:Xa,makeEmptyStoreState:Kn}=kn,{cleanUpNode:Ya,getDownstreamNodes:Ja,setNodeValue:Qa,setUnvalidatedAtomValue_DEPRECATED:es}=Ue,{graph:ts}=Ge,{cloneGraph:ns}=Ge,{applyAtomValueWrites:os}=Ie,{releaseScheduledRetainablesNow:qn}=He,{freshSnapshot:rs}=ht,{useCallback:as,useContext:Zn,useEffect:Ht,useMemo:ss,useRef:Kt,useState:is}=te;function Ke(){throw new Error("This component must be used inside a <RecoilRoot> component.")}const jn=Object.freeze({getState:Ke,replaceState:Ke,getGraph:Ke,subscribeToTransactions:Ke,addTransactionMetadata:Ke});let qt=!1;function Xn(e){if(qt)throw new Error("An atom update was triggered within the execution of a state updater function. State updater functions provided to Recoil must be pure functions.");const t=e.getState();if(t.nextTree===null){G("recoil_memory_managament_2020")&&G("recoil_release_on_cascading_update_killswitch_2021")&&t.commitDepth>0&&qn(e);const n=t.currentTree.version,o=Xa();t.nextTree={...t.currentTree,version:o,stateID:o,dirtyAtoms:new Set,transactionMetadata:{}},t.graphsByVersion.set(o,ns(I(t.graphsByVersion.get(n))))}}const Yn=te.createContext({current:jn}),Zt=()=>Zn(Yn),Jn=te.createContext(null);function cs(){return Zn(Jn)}function Qn(e){const t=e.getState(),n=t.currentTree,o=n.dirtyAtoms;if(o.size){for(const[a,i]of t.nodeTransactionSubscriptions)if(o.has(a))for(const[l,f]of i)f(e);for(const[a,i]of t.transactionSubscriptions)i(e);const r=Ja(e,n,o);for(const a of r){const i=t.nodeToComponentSubscriptions.get(a);if(i)for(const[l,[f,h]]of i)h(n)}t.suspendedComponentResolvers.forEach(a=>a())}t.queuedComponentCallbacks_DEPRECATED.forEach(r=>r(n)),t.queuedComponentCallbacks_DEPRECATED.splice(0,t.queuedComponentCallbacks_DEPRECATED.length)}function ls({setNotifyBatcherOfChange:e}){const t=Zt(),[n,o]=is([]);return e(()=>o({})),Ht(()=>{ea.enqueueExecution("Batcher",()=>{const r=t.current.getState();r.commitDepth++;try{const{nextTree:a}=r;if(a===null)return;r.previousTree=r.currentTree,r.currentTree=a,r.nextTree=null,Qn(t.current);const i=I(r.previousTree).version;r.graphsByVersion.delete(i),r.previousTree=null,G("recoil_memory_managament_2020")&&qn(t.current)}finally{r.commitDepth--}})}),Ht(()=>()=>{e(()=>{})},[e]),null}function us(e,t){const n=Kn();return t({set:(o,r)=>{const a=n.currentTree,i=Qa(e,a,o.key,r),l=new Set(i.keys()),f=a.nonvalidatedAtoms.clone();for(const h of l)f.delete(h);n.currentTree={...a,dirtyAtoms:ya(a.dirtyAtoms,l),atomValues:os(a.atomValues,i),nonvalidatedAtoms:f}},setUnvalidatedAtomValues:o=>{o.forEach((r,a)=>{n.currentTree=es(n.currentTree,a,r)})}}),n}function fs(e){return rs().map(e).getStore_INTERNAL().getState()}let eo=0;function ds({initializeState_DEPRECATED:e,initializeState:t,store_INTERNAL:n,children:o}){var r;let a;const i=b=>{const D=a.current.graphsByVersion;if(D.has(b))return I(D.get(b));const C=ts();return D.set(b,C),C},l=(b,D)=>{if(D==null){const{transactionSubscriptions:C}=A.current.getState(),L=eo++;return C.set(L,b),{release:()=>{C.delete(L)}}}else{const{nodeTransactionSubscriptions:C}=A.current.getState();C.has(D)||C.set(D,new Map);const L=eo++;return I(C.get(D)).set(L,b),{release:()=>{const k=C.get(D);k&&(k.delete(L),k.size===0&&C.delete(D))}}}},f=b=>{Xn(A.current);for(const D of Object.keys(b))I(A.current.getState().nextTree).transactionMetadata[D]=b[D]},h=b=>{const D=A.current.getState();Xn(A.current);const C=I(D.nextTree);let L;try{qt=!0,L=b(C)}finally{qt=!1}L!==C&&(D.nextTree=L,I(p.current)())},p=Kt(null),T=as(b=>{p.current=b},[p]),U=(r=te.createMutableSource)!==null&&r!==void 0?r:te.unstable_createMutableSource,F=n??{getState:()=>a.current,replaceState:h,getGraph:i,subscribeToTransactions:l,addTransactionMetadata:f},A=Kt(F);a=Kt(e!=null?us(F,e):t!=null?fs(t):Kn());const B=ss(()=>U?U(a,()=>a.current.currentTree.version):null,[U,a]);return Ht(()=>()=>{for(const b of A.current.getState().knownAtoms)Ya(A.current,b)},[]),te.createElement(Yn.Provider,{value:A},te.createElement(Jn.Provider,{value:B},te.createElement(ls,{setNotifyBatcherOfChange:T}),o))}function hs(e){const{override:t,...n}=e,o=Zt();return t===!1&&o.current!==jn?te.createElement(te.Fragment,null,e.children):te.createElement(ds,n)}var pt={useStoreRef:Zt,useRecoilMutableSource:cs,RecoilRoot:hs,sendEndOfBatchNotifications_FOR_TESTING:Qn};function ps(e,t){const n=new Map;for(const[o,r]of e)t(r,o)&&n.set(o,r);return n}var vs=ps;function _s(e,t){const n=new Set;for(const o of e)t(o)&&n.add(o);return n}var ms=_s;function ys(e,t){if(!e)throw new Error(t)}var Ss=ys,vt=Ss;function Rs(...e){const t=new Map;for(let n=0;n<e.length;n++){const o=e[n].keys();let r;for(;!(r=o.next()).done;)t.set(r.value,e[n].get(r.value))}return t}var gs=Rs,jt;const to=(jt=te.useMutableSource)!==null&&jt!==void 0?jt:te.unstable_useMutableSource;function bs(){return to&&!(typeof window!="undefined"&&window.$disableRecoilValueMutableSource_TEMP_HACK_DO_NOT_USE)}var ws={mutableSourceExists:bs,useMutableSource:to};function Ts(e,t){if(e===t)return!0;if(e.length!==t.length)return!1;for(let n=0,o=e.length;n<o;n++)if(e[n]!==t[n])return!1;return!0}var As=Ts;const{useRef:Es}=te;function Ns(){const e=Es();return"<component name not available>"}var Xt=Ns;const{batchUpdates:Yt}=Ft,{DEFAULT_VALUE:_t,getNode:no,nodes:Vs}=pe,{useRecoilMutableSource:Cs,useStoreRef:ie}=pt,{AbstractRecoilValue:Jt,getRecoilValueAsLoadable:qe,setRecoilValue:Be,setRecoilValueLoadable:Ls,setUnvalidatedRecoilValue:$s,subscribeToRecoilValue:Qt}=Ie,{updateRetainCount:Ze}=He,{RetentionZone:Ms}=at,{Snapshot:il,cloneSnapshot:je}=ht,{setByAddingToSet:Ds}=dn,{isSSR:mt}=On,{mutableSourceExists:ks,useMutableSource:Us}=ws,{useCallback:ve,useEffect:ge,useMemo:Is,useRef:Te,useState:en}=te,oo=12e4;function ro(e,t,n){if(e.state==="hasValue")return e.contents;throw e.state==="loading"?new Promise(r=>{n.current.getState().suspendedComponentResolvers.add(r)}):e.state==="hasError"?e.contents:new Error(`Invalid value of loadable atom "${t.key}"`)}function Bs(){const e=ie(),[t,n]=en([]),o=Te(new Set);o.current=new Set;const r=Te(new Set),a=Te(new Map),i=ve(f=>{const h=a.current.get(f);h&&(h.release(),a.current.delete(f))},[a]),l=Xt();return ge(()=>{const f=e.current;function h(p,T){!a.current.has(T)||n([])}ct(o.current,r.current).forEach(p=>{if(a.current.has(p))return;const T=Qt(f,new Jt(p),F=>{h(F,p)},l);a.current.set(p,T),f.getState().nextTree?f.getState().queuedComponentCallbacks_DEPRECATED.push(()=>{h(f.getState(),p)}):h(f.getState(),p)}),ct(r.current,o.current).forEach(p=>{i(p)}),r.current=o.current}),ge(()=>{const f=a.current;return()=>f.forEach((h,p)=>i(p))},[i]),Is(()=>{function f(A){return B=>{Be(e.current,A,B)}}function h(A){return()=>Be(e.current,A,_t)}function p(A){return o.current.has(A.key)||(o.current=Ds(o.current,A.key)),qe(e.current,A)}function T(A){const B=p(A);return ro(B,A,e)}function U(A){return[T(A),f(A)]}function F(A){return[p(A),f(A)]}return{getRecoilValue:T,getRecoilValueLoadable:p,getRecoilState:U,getRecoilStateLoadable:F,getSetRecoilState:f,getResetRecoilState:h}},[o,e])}const Fs={current:0};function Ps(e){const t=ie(),n=ve(()=>{const h=t.current,p=h.getState().currentTree;return qe(h,e,p)},[t,e]),o=ve(()=>n(),[n]),r=Xt(),a=ve((h,p)=>{const T=t.current;return Qt(T,e,()=>{if(!G("recoil_suppress_rerender_in_callback"))return p();const F=n();f.current.is(F)||p(),f.current=F},r).release},[t,e,r,n]),i=Cs(),l=Us(i,o,a),f=Te(l);return ge(()=>{f.current=l}),l}function xs(e){const t=ie(),[n,o]=en([]),r=Xt();ge(()=>{const l=t.current,f=l.getState(),h=Qt(l,e,T=>{var U;if(!G("recoil_suppress_rerender_in_callback"))return o([]);const F=qe(l,e,l.getState().currentTree);((U=i.current)===null||U===void 0?void 0:U.is(F))||o(F),i.current=F},r);if(f.nextTree)l.getState().queuedComponentCallbacks_DEPRECATED.push(()=>{i.current=null,o([])});else{var p;if(!G("recoil_suppress_rerender_in_callback"))return o([]);const T=qe(l,e,l.getState().currentTree);((p=i.current)===null||p===void 0?void 0:p.is(T))||o(T),i.current=T}return h.release},[r,e,t]);const a=qe(t.current,e),i=Te(a);return ge(()=>{i.current=a}),a}function tn(e){return G("recoil_memory_managament_2020")&&uo(e),ks()?Ps(e):xs(e)}function ao(e){const t=ie(),n=tn(e);return ro(n,e,t)}function nn(e){const t=ie();return ve(n=>{Be(t.current,e,n)},[t,e])}function Os(e){const t=ie();return ve(()=>{Be(t.current,e,_t)},[t,e])}function zs(e){return[ao(e),nn(e)]}function Ws(e){return[tn(e),nn(e)]}function yt(e){const t=ie();ge(()=>t.current.subscribeToTransactions(e).release,[e,t])}function so(e){const t=e.atomValues.toMap(),n=lt(vs(t,(o,r)=>{const i=no(r).persistence_UNSTABLE;return i!=null&&i.type!=="none"&&o.state==="hasValue"}),o=>o.contents);return gs(e.nonvalidatedAtoms.toMap(),n)}function Gs(e){yt(ve(t=>{let n=t.getState().previousTree;const o=t.getState().currentTree;n||(n=t.getState().currentTree);const r=so(o),a=so(n),i=lt(Vs,f=>{var h,p,T,U;return{persistence_UNSTABLE:{type:(h=(p=f.persistence_UNSTABLE)===null||p===void 0?void 0:p.type)!==null&&h!==void 0?h:"none",backButton:(T=(U=f.persistence_UNSTABLE)===null||U===void 0?void 0:U.backButton)!==null&&T!==void 0?T:!1}}}),l=ms(o.dirtyAtoms,f=>r.has(f)||a.has(f));e({atomValues:r,previousAtomValues:a,atomInfo:i,modifiedAtoms:l,transactionMetadata:{...o.transactionMetadata}})},[e]))}function Hs(e){yt(ve(t=>{const n=je(t,"current"),o=je(t,"previous");e({snapshot:n,previousSnapshot:o})},[e]))}function io(e){const t=Te();return ge(()=>{t.current=e}),t.current}function Ks(){const e=ie(),[t,n]=en(()=>je(e.current)),o=io(t),r=Te();return ge(()=>(r.current&&!mt&&window.clearTimeout(r.current),t.retain()),[t]),yt(ve(a=>n(je(a)),[])),o!==t&&!mt&&(r.current&&(o==null||o.release_INTERNAL(),window.clearTimeout(r.current)),t.retain(),r.current=window.setTimeout(()=>{t.release_INTERNAL(),r.current=null},oo)),t}function co(){const e=ie();return ve(t=>{var n;const o=e.current.getState(),r=(n=o.nextTree)!==null&&n!==void 0?n:o.currentTree,a=t.getStore_INTERNAL().getState().currentTree;Yt(()=>{const i=new Set;for(const h of[r.atomValues.keys(),a.atomValues.keys()])for(const p of h){var l,f;((l=r.atomValues.get(p))===null||l===void 0?void 0:l.contents)!==((f=a.atomValues.get(p))===null||f===void 0?void 0:f.contents)&&no(p).shouldRestoreFromSnapshots&&i.add(p)}i.forEach(h=>{Ls(e.current,new Jt(h),a.atomValues.has(h)?I(a.atomValues.get(h)):_t)}),e.current.replaceState(h=>({...h,stateID:t.getID_INTERNAL()}))})},[e])}function qs(){const e=ie();return(t,n={})=>{Yt(()=>{e.current.addTransactionMetadata(n),t.forEach((o,r)=>$s(e.current,new Jt(r),o))})}}class lo{}const Zs=new lo;function js(e,t){const n=ie(),o=co();return ve((...r)=>{function a(h,p){Be(n.current,h,p)}function i(h){Be(n.current,h,_t)}const l=je(n.current);let f=Zs;return Yt(()=>{const h="useRecoilCallback expects a function that returns a function: it accepts a function of the type (RecoilInterface) => T = R and returns a callback function T => R, where RecoilInterface is an object {snapshot, set, ...} and T and R are the argument and return types of the callback you want to create.  Please see the docs at recoiljs.org for details.";if(typeof e!="function")throw new Error(h);const p=e({set:a,reset:i,snapshot:l,gotoSnapshot:o});if(typeof p!="function")throw new Error(h);f=p(...r)}),f instanceof lo&&vt(!1),f},t!=null?[...t,n]:void 0)}function uo(e){if(!!G("recoil_memory_managament_2020"))return Xs(e)}function Xs(e){const n=(Array.isArray(e)?e:[e]).map(i=>i instanceof Ms?i:i.key),o=ie();ge(()=>{if(!G("recoil_memory_managament_2020"))return;const i=o.current;if(r.current&&!mt)window.clearTimeout(r.current),r.current=null;else for(const l of n)Ze(i,l,1);return()=>{for(const l of n)Ze(i,l,-1)}},[o,...n]);const r=Te(),a=io(n);if(!mt&&(a===void 0||!As(a,n))){const i=o.current;for(const l of n)Ze(i,l,1);if(a)for(const l of a)Ze(i,l,-1);r.current&&window.clearTimeout(r.current),r.current=window.setTimeout(()=>{r.current=null;for(const l of n)Ze(i,l,-1)},oo)}}var Ys={recoilComponentGetRecoilValueCount_FOR_TESTING:Fs,useGotoRecoilSnapshot:co,useRecoilCallback:js,useRecoilInterface:Bs,useRecoilSnapshot:Ks,useRecoilState:zs,useRecoilStateLoadable:Ws,useRecoilTransactionObserver:Hs,useRecoilValue:ao,useRecoilValueLoadable:tn,useRetain:uo,useResetRecoilState:Os,useSetRecoilState:nn,useSetUnvalidatedAtomValues:qs,useTransactionObservation_DEPRECATED:Gs,useTransactionSubscription_DEPRECATED:yt};const{peekNodeInfo:Js}=Ue,{useStoreRef:Qs}=pt;function ei(){const e=Qs();return({key:t})=>Js(e.current,e.current.getState().currentTree,t)}var ti=ei;const{RecoilRoot:ni,useStoreRef:oi}=pt,{useMemo:ri}=te;function ai(){const e=oi().current;return ri(()=>{function t({children:n}){return te.createElement(ni,{store_INTERNAL:e},n)}return t},[e])}var si=ai;function _e(e,t,n){if(typeof e=="string"&&!e.includes('"')&&!e.includes("\\"))return`"${e}"`;switch(typeof e){case"undefined":return"";case"boolean":return e?"true":"false";case"number":case"symbol":return String(e);case"string":return JSON.stringify(e);case"function":if((t==null?void 0:t.allowFunctions)!==!0)throw new Error("Attempt to serialize function in a Recoil cache key");return`__FUNCTION(${e.name})__`}if(e===null)return"null";if(typeof e!="object"){var o;return(o=JSON.stringify(e))!==null&&o!==void 0?o:""}if(q(e))return"__PROMISE__";if(Array.isArray(e))return`[${e.map((r,a)=>_e(r,t,a.toString()))}]`;if(typeof e.toJSON=="function")return _e(e.toJSON(n),t,n);if(e instanceof Map){const r={};for(const[a,i]of e)r[typeof a=="string"?a:_e(a,t)]=i;return _e(r,t,n)}return e instanceof Set?_e(Array.from(e).sort((r,a)=>_e(r,t).localeCompare(_e(a,t))),t,n):Symbol!==void 0&&e[Symbol.iterator]!=null&&typeof e[Symbol.iterator]=="function"?_e(Array.from(e),t,n):`{${Object.keys(e).filter(r=>e[r]!==void 0).sort().map(r=>`${_e(r,t)}:${_e(e[r],t,r)}`).join(",")}}`}function ii(e,t={allowFunctions:!1}){return _e(e,t)}var St=ii;class ci{constructor(t){var n,o,r;x(this,"_numLeafs",void 0),x(this,"_root",void 0),x(this,"_onHit",void 0),x(this,"_onSet",void 0),x(this,"_mapNodeValue",void 0),this._numLeafs=0,this._root=null,this._onHit=(n=t==null?void 0:t.onHit)!==null&&n!==void 0?n:()=>{},this._onSet=(o=t==null?void 0:t.onSet)!==null&&o!==void 0?o:()=>{},this._mapNodeValue=(r=t==null?void 0:t.mapNodeValue)!==null&&r!==void 0?r:a=>a}size(){return this._numLeafs}root(){return this._root}get(t,n){var o;return(o=this.getLeafNode(t,n))===null||o===void 0?void 0:o.value}getLeafNode(t,n){return fo(this.root(),o=>this._mapNodeValue(t(o)),{onNodeVisit:o=>{n==null||n.onNodeVisit(o),o.type==="leaf"&&this._onHit(o)}})}set(t,n,o){let r;const a=on(this.root(),t.map(([i,l])=>[i,this._mapNodeValue(l)]),null,n,null,{onNodeVisit:i=>{o==null||o.onNodeVisit(i),i.type==="leaf"&&(r=i)}});this.root()||(this._root=a),this._numLeafs++,this._onSet(I(r))}delete(t){if(!this.root())return!1;const n=I(this.root());return li(n,t,t.parent)?t===n||n.type==="branch"&&!n.branches.size?(this._root=null,this._numLeafs=0,!0):(this._numLeafs-=po(t),!0):!1}clear(){this._numLeafs=0,this._root=null}}const fo=(e,t,n)=>{var o;if(e==null)return;if(n==null||(o=n.onNodeVisit)===null||o===void 0||o.call(n,e),e.type==="leaf")return e;const r=t(e.nodeKey);return fo(e.branches.get(r),t,n)},on=(e,t,n,o,r,a)=>{var i;let l;if(e==null)if(t.length===0)l={type:"leaf",value:o,parent:n,branchKey:r};else{const[f,...h]=t,[p,T]=f;l={type:"branch",nodeKey:p,parent:n,branches:new Map,branchKey:r},l.branches.set(T,on(null,h,l,o,T,a))}else if(l=e,t.length){const[f,...h]=t,[p,T]=f;e.type==="branch"&&e.nodeKey===p||vt(!1),e.branches.set(T,on(e.branches.get(T),h,e,o,T,a))}return a==null||(i=a.onNodeVisit)===null||i===void 0||i.call(a,l),l},li=(e,t,n)=>n?(n.branches.delete(t.branchKey),ho(e,n,n.parent)):e===t,ho=(e,t,n)=>n?(t.branches.size===0&&n.branches.delete(t.branchKey),ho(e,n,n.parent)):e===t,po=e=>e.type==="leaf"?1:Array.from(e.branches.values()).reduce((t,n)=>t+po(n),0);var ui={TreeCache:ci},fi=ui.TreeCache,vo=Object.freeze({__proto__:null,TreeCache:fi});class di{constructor(t){var n;x(this,"_maxSize",void 0),x(this,"_size",void 0),x(this,"_head",void 0),x(this,"_tail",void 0),x(this,"_map",void 0),x(this,"_keyMapper",void 0),this._maxSize=t.maxSize,this._size=0,this._head=null,this._tail=null,this._map=new Map,this._keyMapper=(n=t.mapKey)!==null&&n!==void 0?n:o=>o}head(){return this._head}tail(){return this._tail}size(){return this._size}maxSize(){return this._maxSize}has(t){return this._map.has(this._keyMapper(t))}get(t){const n=this._keyMapper(t),o=this._map.get(n);if(!!o)return this.set(t,o.value),o.value}set(t,n){const o=this._keyMapper(t);this._map.get(o)&&this.delete(t);const a=this.head(),i={key:t,right:a,left:null,value:n};a?a.left=i:this._tail=i,this._map.set(o,i),this._head=i,this._size++,this._maybeDeleteLRU()}_maybeDeleteLRU(){this.size()>this.maxSize()&&this.deleteLru()}deleteLru(){const t=this.tail();t&&this.delete(t.key)}delete(t){const n=this._keyMapper(t);if(!this._size||!this._map.has(n))return;const o=I(this._map.get(n)),r=o.right,a=o.left;r&&(r.left=o.left),a&&(a.right=o.right),o===this.head()&&(this._head=r),o===this.tail()&&(this._tail=a),this._map.delete(n),this._size--}clear(){this._size=0,this._head=null,this._tail=null,this._map=new Map}}var hi={LRUCache:di},pi=hi.LRUCache,_o=Object.freeze({__proto__:null,LRUCache:pi});const{LRUCache:vi}=_o,{TreeCache:_i}=vo;function mi(e,t=n=>n){const n=new vi({maxSize:e}),o=new _i({mapNodeValue:t,onHit:r=>{n.set(r,!0)},onSet:r=>{const a=n.tail();n.set(r,!0),a&&o.size()>e&&o.delete(a.key)}});return o}var yi=mi;const{TreeCache:Si}=vo,Rt={equality:"reference",eviction:"none",maxSize:Infinity};function Ri({equality:e=Rt.equality,eviction:t=Rt.eviction,maxSize:n=Rt.maxSize}=Rt){const o=gi(e);return bi(t,n,o)}function gi(e){switch(e){case"reference":return t=>t;case"value":return t=>St(t)}throw new Error(`Unrecognized equality policy ${e}`)}function bi(e,t,n){switch(e){case"none":return new Si({mapNodeValue:n});case"lru":return yi(I(t),n)}throw new Error(`Unrecognized eviction policy ${e}`)}var wi=Ri;function Ti(e){return()=>null}var Ai={startPerfBlock:Ti};const{CANCELED:Xe,Canceled:Ei,loadableWithError:Ye,loadableWithPromise:Ni,loadableWithValue:rn}=nt,{getNodeLoadable:mo,peekNodeLoadable:Vi,setNodeValue:Ci}=Ue,{saveDependencyMapToStore:Li}=Ge,{DEFAULT_VALUE:$i,RecoilValueNotReady:Mi,getConfigDeletionHandler:Di,registerNode:yo}=pe,{isRecoilValue:ki}=Le,{AbstractRecoilValue:Ui}=Le,{setRecoilValueLoadable:Ii}=Ie,{retainedByOptionWithDefault:Bi}=He,{cloneSnapshot:Fi}=ht,{startPerfBlock:Pi}=Ai,Je=[],gt=new Map,xi=(()=>{let e=0;return()=>e++})();function Oi(){return{depValuesDiscoveredSoFarDuringAsyncWork:null,latestLoadable:null,latestExecutionId:null,stateVersion:null}}function zi(e){const{key:t,get:n,cachePolicy_UNSTABLE:o}=e,r=e.set!=null?e.set:void 0,a=wi(o??{equality:"reference",eviction:"none"}),i=Bi(e.retainedBy_UNSTABLE),l=new Map;let f=0;function h(){return!G("recoil_memory_managament_2020")||f>0}function p(u){return l.has(u)||l.set(u,Oi()),I(l.get(u))}function T(u){return f++,u.getState().knownSelectors.add(t),()=>{f--,u.getState().knownSelectors.delete(t),l.delete(u)}}function U(){return Di(t)!==void 0&&!h()}function F(u,y,v){if(y.state==="loading"){let w=gt.get(v);w==null&&gt.set(v,w=new Set),w.add(u)}}function A(u,y){const v=gt.get(y);if(v!==void 0){for(const w of v)Ii(w,new Ui(t),u);gt.delete(y)}}function B(u,y,v){if(y.atomValues.has(v))return I(y.atomValues.get(v));const w=mo(u,y,v),g=u.getState().knownSelectors.has(v);return w.state!=="loading"&&g&&y.atomValues.set(v,w),w}function b(u,y,v,w,g){return y.then(S=>{if(!h())return me(u,g),Xe;const P=rn(S);return le(v,X(w),P),L(u,v,new Set(w.keys()),g),C(u,P,g),{__value:S,__key:t}}).catch(S=>{if(!h())return me(u,g),Xe;if(ne(u,g)&&re(w,u,g),q(S))return D(u,S,v,w,g);const P=Ye(S);throw le(v,X(w),P),L(u,v,new Set(w.keys()),g),C(u,P,g),S})}function D(u,y,v,w,g){return y.then(S=>{if(!h())return me(u,g),Xe;if(S instanceof Ei)return Xe;const{__key:P,__value:J}=S??{};let j=!0;P!=null&&(v.atomValues.set(P,rn(J)),j=!1);const[O,W]=H(u,v,g,j);if(ne(u,g)&&re(W,u,g),ye(O),O.state!=="loading"&&(le(v,X(W),O),L(u,v,new Set(W.keys()),g),C(u,O,g)),O.state==="hasError")throw O.contents;return O.state==="hasValue"?{__value:O.contents,__key:t}:O.contents}).catch(S=>{if(!h())return me(u,g),Xe;const P=Ye(S);throw le(v,X(w),Ye(S)),L(u,v,new Set(w.keys()),g),C(u,P,g),S})}function C(u,y,v){ne(u,v)&&(Z(y,u),A(y,v))}function L(u,y,v,w){var g,S,P,J;if(ne(u,w)||y.version===((g=u.getState())===null||g===void 0||(S=g.currentTree)===null||S===void 0?void 0:S.version)||y.version===((P=u.getState())===null||P===void 0||(J=P.nextTree)===null||J===void 0?void 0:J.version)){var j,O,W;Li(new Map([[t,v]]),u,(j=(O=u.getState())===null||O===void 0||(W=O.nextTree)===null||W===void 0?void 0:W.version)!==null&&j!==void 0?j:u.getState().currentTree.version)}}function k(u,y,v,w,g){v.add(w),L(u,y,v,g)}function H(u,y,v,w=!1){const g=Pi(t);let S,P=!1,J;const j=new Map,O=new Set;L(u,y,O,v);function W(Re){const{key:fe}=Re;k(u,y,O,fe,v);const de=w?mo(u,y,fe):B(u,y,fe);if(ye(de),j.set(fe,de),de.state==="hasValue")return de.contents;throw de.contents}let oe=!1;const xe=Re=>(...fe)=>{if(!oe)throw new Error("getCallback() should only be called asynchronously after the selector is evalutated.  It can be used for selectors to return objects with callbacks that can obtain the current Recoil state without a subscription.");const de=Fi(u),Me=Re({snapshot:de});if(typeof Me!="function")throw new Error("getCallback() expects a function that returns a function.");return Me(...fe)};try{S=n({get:W,getCallback:xe}),S=ki(S)?W(S):S,oe=!0,q(S)?S=b(u,S,y,j,v).finally(g):g()}catch(Re){S=Re,q(S)?S=D(u,S,y,j,v).finally(g):(P=!0,g())}return P?J=Ye(S):q(S)?J=Ni(S):J=rn(S),ye(J),[J,j]}function Y(u,y){const v=new Set,w=p(u),g=a.get(S=>(typeof S!="string"&&vt(!1),B(u,y,S).contents),{onNodeVisit:S=>{S.type==="branch"&&S.nodeKey!==t&&typeof S.nodeKey=="string"&&v.add(S.nodeKey)}});return g&&L(u,y,v,w.latestExecutionId),g}function X(u){return Array.from(u.entries()).map(([y,v])=>[y,v.contents])}function K(u,y){const v=xi(),[w,g]=H(u,y,v);return Z(w,u,g,v,y),Se(y,X(g),w),F(u,w,v),w}function ce(u,y){const v=Y(u,y);if(v!=null)return Z(v,u),v;const w=be(u,y);if(w){const g=w;return F(u,I(g.latestLoadable),I(g.latestExecutionId)),I(g.latestLoadable)}return K(u,y)}function be(u,y){var v;const[,w]=(v=Array.from(l.entries()).find(([,g])=>g.latestLoadable!=null&&g.latestExecutionId!=null&&!ee(u,y)))!==null&&v!==void 0?v:[];return w}const we=new Map;function ee(u,y){var v,w;const g=p(u),S=(v=g.depValuesDiscoveredSoFarDuringAsyncWork)!==null&&v!==void 0?v:new Map,P=Array(((w=we.get(y.version))!==null&&w!==void 0?w:new Map).entries()),J=we.has(y.version)&&P.length===S.size&&P.every(([j,O])=>S.get(j)===O);return S==null||y.version===g.stateVersion||J?!1:(we.set(y.version,new Map(S)),Array.from(S).some(([j,O])=>{const W=B(u,y,j);return W.contents!==O.contents&&!(O.state==="loading"&&W.state!=="loading")}))}function Z(u,y,v,w,g){const S=p(y);u.state==="loading"?(S.depValuesDiscoveredSoFarDuringAsyncWork=v,S.latestExecutionId=w,S.latestLoadable=u,S.stateVersion=g==null?void 0:g.version):(S.depValuesDiscoveredSoFarDuringAsyncWork=null,S.latestExecutionId=null,S.latestLoadable=null,S.stateVersion=null)}function Se(u,y,v){v.state!=="loading"&&le(u,y,v)}function re(u,y,v){const w=p(y);ne(y,v)&&(w.depValuesDiscoveredSoFarDuringAsyncWork=u)}function me(u,y){ne(u,y)&&l.delete(u)}function ne(u,y){const v=p(u);return y===v.latestExecutionId}function ye(u){u.state!=="loading"&&Ne(u.contents)}function Ne(u){}function le(u,y,v){u.atomValues.set(t,v),a.set(y,v)}function Ve(u){if(Je.includes(t)){const y=`Recoil selector has circular dependencies: ${Je.slice(Je.indexOf(t)).join(" → ")}`;return Ye(new Error(y))}Je.push(t);try{return u()}finally{Je.pop()}}function $(u,y){return a.get(w=>{typeof w!="string"&&vt(!1);const g=Vi(u,y,w);return g==null?void 0:g.contents})}function ue(u,y){return Ve(()=>ce(u,y))}function Ce(u){u.atomValues.delete(t)}return r!=null?yo({key:t,peek:$,get:ue,set:(y,v,w)=>{let g=!1;const S=new Map;function P({key:W}){if(g)throw new Error("Recoil: Async selector sets are not currently supported.");const oe=B(y,v,W);if(ye(oe),oe.state==="hasValue")return oe.contents;throw oe.state==="loading"?new Mi(W):oe.contents}function J(W,oe){if(g)throw new Error("Recoil: Async selector sets are not currently supported.");const xe=typeof oe=="function"?oe(P(W)):oe;Ci(y,v,W.key,xe).forEach((fe,de)=>S.set(de,fe))}function j(W){J(W,$i)}const O=r({set:J,get:P,reset:j},w);if(O!==void 0)throw q(O)?new Error("Recoil: Async selector sets are not currently supported."):new Error("Recoil: selector set should be a void function.");return g=!0,S},init:T,invalidate:Ce,shouldDeleteConfigOnRelease:U,dangerouslyAllowMutability:e.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1,retainedBy:i}):yo({key:t,peek:$,get:ue,init:T,invalidate:Ce,shouldDeleteConfigOnRelease:U,dangerouslyAllowMutability:e.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1,retainedBy:i})}var bt=zi;const{loadableWithError:So,loadableWithPromise:Ro,loadableWithValue:Qe}=nt,{DEFAULT_VALUE:Ae,DefaultValue:Fe,getConfigDeletionHandler:go,registerNode:Wi,setConfigDeletionHandler:Gi}=pe,{isRecoilValue:Hi}=Le,{markRecoilValueModified:Ki,setRecoilValue:bo,setRecoilValueLoadable:qi}=Ie,{retainedByOptionWithDefault:Zi}=He;function ji(e){const{key:t,persistence_UNSTABLE:n}=e,o=Zi(e.retainedBy_UNSTABLE);let r=0,a=q(e.default)?Ro(e.default.then(b=>(a=Qe(b),{__key:t,__value:b})).catch(b=>{throw a=So(b),b})):Qe(e.default),i;const l=new Map;function f(b,D){const C=D.then(L=>{var k,H;return((H=((k=b.getState().nextTree)!==null&&k!==void 0?k:b.getState().currentTree).atomValues.get(t))===null||H===void 0?void 0:H.contents)===C&&bo(b,B,L),{__key:t,__value:L}}).catch(L=>{var k,H;throw((H=((k=b.getState().nextTree)!==null&&k!==void 0?k:b.getState().currentTree).atomValues.get(t))===null||H===void 0?void 0:H.contents)===C&&qi(b,B,So(L)),L});return C}function h(b,D,C){r++;const L=b.getState().knownAtoms.has(t);if(b.getState().knownAtoms.add(t),a.state==="loading"){const K=()=>{var ce;((ce=b.getState().nextTree)!==null&&ce!==void 0?ce:b.getState().currentTree).atomValues.has(t)||Ki(b,B)};a.contents.then(K).catch(K)}let k=Ae,H=null;if(e.effects_UNSTABLE!=null&&!L){let K=!0;const ce=ee=>Z=>{if(K){const Se=k instanceof Fe||q(k)?a.state==="hasValue"?a.contents:Ae:k;k=typeof Z=="function"?Z(Se):Z,q(k)&&(k=k.then(re=>(H={effect:ee,value:re},re)))}else{if(q(Z))throw new Error("Setting atoms to async values is not implemented.");typeof Z!="function"&&(H={effect:ee,value:Z}),bo(b,B,typeof Z=="function"?Se=>{const re=Z(Se);return H={effect:ee,value:re},re}:Z)}},be=ee=>()=>ce(ee)(Ae),we=ee=>Z=>{b.subscribeToTransactions(Se=>{let{currentTree:re,previousTree:me}=Se.getState();me||(me=re);const ne=re.atomValues.get(t);if(ne==null||ne.state==="hasValue"){var ye,Ne,le,Ve;const $=ne!=null?ne.contents:Ae,ue=(ye=me.atomValues.get(t))!==null&&ye!==void 0?ye:a,Ce=ue.state==="hasValue"?ue.contents:Ae;((Ne=H)===null||Ne===void 0?void 0:Ne.effect)!==ee||((le=H)===null||le===void 0?void 0:le.value)!==$?Z($,Ce):((Ve=H)===null||Ve===void 0?void 0:Ve.effect)===ee&&(H=null)}},t)};for(const ee of(Y=e.effects_UNSTABLE)!==null&&Y!==void 0?Y:[]){var Y;const Z=ee({node:B,trigger:C,setSelf:ce(ee),resetSelf:be(ee),onSet:we(ee)});Z!=null&&l.set(b,Z)}K=!1}if(!(k instanceof Fe)){var X;const K=q(k)?Ro(f(b,k)):Qe(k);D.atomValues.set(t,K),(X=b.getState().nextTree)===null||X===void 0||X.atomValues.set(t,K)}return()=>{var K;r--,(K=l.get(b))===null||K===void 0||K(),l.delete(b),b.getState().knownAtoms.delete(t)}}function p(b,D){var C,L,k;return(C=(L=D.atomValues.get(t))!==null&&L!==void 0?L:(k=i)===null||k===void 0?void 0:k[1])!==null&&C!==void 0?C:a}function T(b,D){if(D.atomValues.has(t))return I(D.atomValues.get(t));if(D.nonvalidatedAtoms.has(t)){if(i!=null)return i;if(n==null)return a;const C=D.nonvalidatedAtoms.get(t),L=n.validator(C,Ae);return i=L instanceof Fe?a:Qe(L),i}else return a}function U(){i=void 0}function F(b,D,C){if(D.atomValues.has(t)){const L=I(D.atomValues.get(t));if(L.state==="hasValue"&&C===L.contents)return new Map}else if(!D.nonvalidatedAtoms.has(t)&&C instanceof Fe)return new Map;return i=void 0,new Map().set(t,Qe(C))}function A(){return go(t)!==void 0&&r<=0}const B=Wi({key:t,peek:p,get:T,set:F,init:h,invalidate:U,shouldDeleteConfigOnRelease:A,dangerouslyAllowMutability:e.dangerouslyAllowMutability,persistence_UNSTABLE:e.persistence_UNSTABLE?{type:e.persistence_UNSTABLE.type,backButton:e.persistence_UNSTABLE.backButton}:void 0,shouldRestoreFromSnapshots:!0,retainedBy:o});return B}function wo(e){const{default:t,...n}=e;return Hi(t)?Xi({...n,default:t}):ji({...n,default:t})}function Xi(e){const t=wo({...e,default:Ae,persistence_UNSTABLE:e.persistence_UNSTABLE===void 0?void 0:{...e.persistence_UNSTABLE,validator:o=>o instanceof Fe?o:I(e.persistence_UNSTABLE).validator(o,Ae)},effects_UNSTABLE:e.effects_UNSTABLE}),n=bt({key:`${e.key}__withFallback`,get:({get:o})=>{const r=o(t);return r instanceof Fe?e.default:r},set:({set:o},r)=>o(t,r),dangerouslyAllowMutability:e.dangerouslyAllowMutability});return Gi(n.key,go(e.key)),n}var To=wo;class Yi{constructor(t){var n;x(this,"_map",void 0),x(this,"_keyMapper",void 0),this._map=new Map,this._keyMapper=(n=t==null?void 0:t.mapKey)!==null&&n!==void 0?n:o=>o}size(){return this._map.size}has(t){return this._map.has(this._keyMapper(t))}get(t){return this._map.get(this._keyMapper(t))}set(t,n){this._map.set(this._keyMapper(t),n)}delete(t){this._map.delete(this._keyMapper(t))}clear(){this._map.clear()}}var Ji={MapCache:Yi},Qi=Ji.MapCache,ec=Object.freeze({__proto__:null,MapCache:Qi});const{LRUCache:tc}=_o,{MapCache:nc}=ec,wt={equality:"reference",eviction:"none",maxSize:Infinity};function oc({equality:e=wt.equality,eviction:t=wt.eviction,maxSize:n=wt.maxSize}=wt){const o=rc(e);return ac(t,n,o)}function rc(e){switch(e){case"reference":return t=>t;case"value":return t=>St(t)}throw new Error(`Unrecognized equality policy ${e}`)}function ac(e,t,n){switch(e){case"none":return new nc({mapKey:n});case"lru":return new tc({mapKey:n,maxSize:I(t)})}throw new Error(`Unrecognized eviction policy ${e}`)}var Ao=oc;const{setConfigDeletionHandler:sc}=pe;function ic(e){var t;const n=Ao((t=e.cachePolicyForParams_UNSTABLE)!==null&&t!==void 0?t:{equality:"value",eviction:"none"});return o=>{var r;const a=n.get(o);if(a!=null)return a;const{cachePolicyForParams_UNSTABLE:i,...l}=e,f=To({...l,key:`${e.key}__${(r=St(o))!==null&&r!==void 0?r:"void"}`,default:typeof e.default=="function"?e.default(o):e.default,retainedBy_UNSTABLE:typeof e.retainedBy_UNSTABLE=="function"?e.retainedBy_UNSTABLE(o):e.retainedBy_UNSTABLE,effects_UNSTABLE:typeof e.effects_UNSTABLE=="function"?e.effects_UNSTABLE(o):e.effects_UNSTABLE});return n.set(o,f),sc(f.key,()=>{n.delete(o)}),f}}var cc=ic;const{setConfigDeletionHandler:lc}=pe;let uc=0;function fc(e){var t;const n=Ao((t=e.cachePolicyForParams_UNSTABLE)!==null&&t!==void 0?t:{equality:"value",eviction:"none"});return o=>{var r;const a=n.get(o);if(a!=null)return a;const i=`${e.key}__selectorFamily/${(r=St(o,{allowFunctions:!0}))!==null&&r!==void 0?r:"void"}/${uc++}`,l=T=>e.get(o)(T),f=e.cachePolicy_UNSTABLE,h=typeof e.retainedBy_UNSTABLE=="function"?e.retainedBy_UNSTABLE(o):e.retainedBy_UNSTABLE;let p;if(e.set!=null){const T=e.set;p=bt({key:i,get:l,set:(F,A)=>T(o)(F,A),cachePolicy_UNSTABLE:f,dangerouslyAllowMutability:e.dangerouslyAllowMutability,retainedBy_UNSTABLE:h})}else p=bt({key:i,get:l,cachePolicy_UNSTABLE:f,dangerouslyAllowMutability:e.dangerouslyAllowMutability,retainedBy_UNSTABLE:h});return n.set(o,p),lc(p.key,()=>{n.delete(o)}),p}}var Ee=fc;const dc=Ee({key:"__constant",get:e=>()=>e,cachePolicyForParams_UNSTABLE:{equality:"reference"}});function hc(e){return dc(e)}var pc=hc;const vc=Ee({key:"__error",get:e=>()=>{throw new Error(e)},cachePolicyForParams_UNSTABLE:{equality:"reference"}});function _c(e){return vc(e)}var mc=_c;function yc(e){return e}var Sc=yc;const{loadableWithError:Eo,loadableWithPromise:No,loadableWithValue:Vo}=nt;function Tt(e,t){const n=Array(t.length).fill(void 0),o=Array(t.length).fill(void 0);for(const[r,a]of t.entries())try{n[r]=e(a)}catch(i){o[r]=i}return[n,o]}function Rc(e){return e!=null&&!q(e)}function At(e){return Array.isArray(e)?e:Object.getOwnPropertyNames(e).map(t=>e[t])}function an(e){return e!=null&&typeof e=="object"&&e.hasOwnProperty("__value")?e.__value:e}function sn(e,t){return Array.isArray(e)?t:Object.getOwnPropertyNames(e).reduce((n,o,r)=>({...n,[o]:t[r]}),{})}function Pe(e,t,n){const o=n.map((r,a)=>r==null?Vo(t[a]):q(r)?No(r):Eo(r));return sn(e,o)}function gc(e,t){return t.map((n,o)=>n===void 0?e[o]:n)}const bc=Ee({key:"__waitForNone",get:e=>({get:t})=>{const n=At(e),[o,r]=Tt(t,n);return Pe(e,o,r)}}),wc=Ee({key:"__waitForAny",get:e=>({get:t})=>{const n=At(e),[o,r]=Tt(t,n);return r.some(a=>!q(a))?Pe(e,o,r):new Promise(a=>{for(const[i,l]of r.entries())q(l)&&l.then(f=>{o[i]=an(f),r[i]=void 0,a(Pe(e,o,r))}).catch(f=>{r[i]=f,a(Pe(e,o,r))})})}}),Tc=Ee({key:"__waitForAll",get:e=>({get:t})=>{const n=At(e),[o,r]=Tt(t,n);if(r.every(i=>i==null))return sn(e,o);const a=r.find(Rc);if(a!=null)throw a;return Promise.all(r).then(i=>sn(e,gc(o,i).map(an)))}}),Ac=Ee({key:"__waitForAllSettled",get:e=>({get:t})=>{const n=At(e),[o,r]=Tt(t,n);return r.every(a=>!q(a))?Pe(e,o,r):Promise.all(r.map((a,i)=>q(a)?a.then(l=>{o[i]=an(l),r[i]=void 0}).catch(l=>{o[i]=void 0,r[i]=l}):null)).then(()=>Pe(e,o,r))}}),Ec=Ee({key:"__noWait",get:e=>({get:t})=>{try{return Vo(t(e))}catch(n){return q(n)?No(n):Eo(n)}}});var Nc={waitForNone:bc,waitForAny:wc,waitForAll:Tc,waitForAllSettled:Ac,noWait:Ec};const{batchUpdates:Vc,setBatcher:Cc}=Ft,{DefaultValue:Lc}=pe,{RecoilRoot:$c}=pt,{isRecoilValue:Mc}=Le,{retentionZone:Dc}=at,{freshSnapshot:kc}=ht,{useGotoRecoilSnapshot:Uc,useRecoilCallback:Ic,useRecoilSnapshot:Bc,useRecoilState:Fc,useRecoilStateLoadable:Pc,useRecoilTransactionObserver:xc,useRecoilValue:Oc,useRecoilValueLoadable:zc,useResetRecoilState:Wc,useRetain:Gc,useSetRecoilState:Hc,useSetUnvalidatedAtomValues:Kc,useTransactionObservation_DEPRECATED:qc}=Ys,{noWait:Zc,waitForAll:jc,waitForAllSettled:Xc,waitForAny:Yc,waitForNone:Jc}=Nc;var et={DefaultValue:Lc,RecoilRoot:$c,useRecoilBridgeAcrossReactRoots_UNSTABLE:si,atom:To,selector:bt,retentionZone:Dc,atomFamily:cc,selectorFamily:Ee,constSelector:pc,errorSelector:mc,readOnlySelector:Sc,useRecoilValue:Oc,useRecoilValueLoadable:zc,useRecoilState:Fc,useRecoilStateLoadable:Pc,useSetRecoilState:Hc,useResetRecoilState:Wc,useGetRecoilValueInfo_UNSTABLE:ti,useRetain:Gc,useRecoilCallback:Ic,useGotoRecoilSnapshot:Uc,useRecoilSnapshot:Bc,useRecoilTransactionObserver_UNSTABLE:xc,useTransactionObservation_UNSTABLE:qc,useSetUnvalidatedAtomValues_UNSTABLE:Kc,noWait:Zc,waitForNone:Jc,waitForAny:Yc,waitForAll:jc,waitForAllSettled:Xc,isRecoilValue:Mc,batchUpdates:Vc,setBatcher:Cc,snapshot_UNSTABLE:kc},Qc=et.RecoilRoot,el=et.atom,tl=et.selector,nl=et.useRecoilValue,ol=et.useRecoilState;export{Qc as RecoilRoot,el as atom,tl as selector,ol as useRecoilState,nl as useRecoilValue};
