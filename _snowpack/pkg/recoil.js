import{r as Bo}from"./common/index-6302b3fe.js";import{r as te}from"./common/index-4b0af3e2.js";function Fo(e){return!!e&&typeof e.then=="function"}var q=Fo;function Po(e,t){if(e!=null)return e;throw new Error(t??"Got unexpected null or undefined")}var I=Po;class un{}const xo=new un,Vt={valueMaybe(){},valueOrThrow(){throw new Error(`Loadable expected value, but in "${this.state}" state`)},errorMaybe(){},errorOrThrow(){throw new Error(`Loadable expected error, but in "${this.state}" state`)},promiseMaybe(){},promiseOrThrow(){throw new Error(`Loadable expected promise, but in "${this.state}" state`)},is(e){return e.state===this.state&&e.contents===this.contents},map(e){if(this.state==="hasError")return this;if(this.state==="hasValue")try{const n=e(this.contents);return q(n)?ke(n):Ct(n)}catch(n){return q(n)?ke(n.next(()=>e(this.contents))):Lt(n)}if(this.state==="loading")return ke(this.contents.then(e).catch(n=>{if(q(n))return n.then(()=>e(this.contents));throw n}));throw new Error("Invalid Loadable state")}};function Ct(e){return Object.freeze({state:"hasValue",contents:e,...Vt,getValue(){return this.contents},toPromise(){return Promise.resolve(this.contents)},valueMaybe(){return this.contents},valueOrThrow(){return this.contents}})}function Lt(e){return Object.freeze({state:"hasError",contents:e,...Vt,getValue(){throw this.contents},toPromise(){return Promise.reject(this.contents)},errorMaybe(){return this.contents},errorOrThrow(){return this.contents}})}function ke(e){return Object.freeze({state:"loading",contents:e,...Vt,getValue(){throw this.contents.then(({__value:t})=>t)},toPromise(){return this.contents.then(({__value:t})=>t)},promiseMaybe(){return this.contents.then(({__value:t})=>t)},promiseOrThrow(){return this.contents.then(({__value:t})=>t)}})}function Oo(){return ke(new Promise(()=>{}))}function zo(e){return e.every(t=>t.state==="hasValue")?Ct(e.map(t=>t.contents)):e.some(t=>t.state==="hasError")?Lt(I(e.find(t=>t.state==="hasError"),"Invalid loadable passed to loadableAll").contents):ke(Promise.all(e.map(t=>t.contents)).then(t=>({__value:t})))}var nt={loadableWithValue:Ct,loadableWithError:Lt,loadableWithPromise:ke,loadableLoading:Oo,loadableAll:zo,Canceled:un,CANCELED:xo};function Wo(e,t,{error:n}={}){return null}var Go=Wo,Ho=Go;function Ko(e,t){const n=new Set(e);return n.add(t),n}function qo(e,t){const n=new Set(e);return n.delete(t),n}function Zo(e,t,n){const o=new Map(e);return o.set(t,n),o}function jo(e,t,n){const o=new Map(e);return o.set(t,n(o.get(t))),o}function Xo(e,t){const n=new Map(e);return n.delete(t),n}function Yo(e,t){const n=new Map(e);return t.forEach(o=>n.delete(o)),n}var fn={setByAddingToSet:Ko,setByDeletingFromSet:qo,mapBySettingInMap:Zo,mapByUpdatingInMap:jo,mapByDeletingFromMap:Xo,mapByDeletingMultipleFromMap:Yo};function*Jo(e,t){let n=0;for(const o of e)t(o,n++)&&(yield o)}var dn=Jo;const $t=new Map().set("recoil_hamt_2020",!0).set("recoil_memory_managament_2020",!0);function Mt(e){var t;return(t=$t.get(e))!==null&&t!==void 0?t:!1}Mt.setPass=e=>{$t.set(e,!0)},Mt.setFail=e=>{$t.set(e,!1)};var G=Mt;function Qo(e,t){return function*(){let n=0;for(const o of e)yield t(o,n++)}()}var hn=Qo;function P(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}class Dt{constructor(t){P(this,"key",void 0),this.key=t}}class pn extends Dt{}class vn extends Dt{}function er(e){return e instanceof pn||e instanceof vn}var ot={AbstractRecoilValue:Dt,RecoilState:pn,RecoilValueReadOnly:vn,isRecoilValue:er},tr=ot.AbstractRecoilValue,nr=ot.RecoilState,or=ot.RecoilValueReadOnly,rr=ot.isRecoilValue,Le=Object.freeze({__proto__:null,AbstractRecoilValue:tr,RecoilState:nr,RecoilValueReadOnly:or,isRecoilValue:rr});class _n{}const ar=new _n;class sr extends Error{constructor(t){super(`Tried to set the value of Recoil selector ${t} using an updater function, but it is an async selector in a pending or error state; this is not supported.`)}}const $e=new Map,kt=new Map;function ir(e){return hn(e,t=>I(kt.get(t)))}function cr(e){if($e.has(e.key)){const n=`Duplicate atom key "${e.key}". This is a FATAL ERROR in
      production. But it is safe to ignore this warning if it occurred because of
      hot module replacement.`;console.warn(n)}$e.set(e.key,e);const t=e.set==null?new Le.RecoilValueReadOnly(e.key):new Le.RecoilState(e.key);return kt.set(e.key,t),t}class mn extends Error{}function lr(e){const t=$e.get(e);if(t==null)throw new mn(`Missing definition for RecoilValue: "${e}""`);return t}function ur(e){return $e.get(e)}const rt=new Map;function fr(e){var t;if(!G("recoil_memory_managament_2020"))return;const n=$e.get(e);if(n==null||(t=n.shouldDeleteConfigOnRelease)===null||t===void 0?void 0:t.call(n)){var o;$e.delete(e),(o=yn(e))===null||o===void 0||o(),rt.delete(e)}}function dr(e,t){!G("recoil_memory_managament_2020")||(t===void 0?rt.delete(e):rt.set(e,t))}function yn(e){return rt.get(e)}var he={nodes:$e,recoilValues:kt,registerNode:cr,getNode:lr,getNodeMaybe:ur,deleteNodeConfigIfPossible:fr,setConfigDeletionHandler:dr,getConfigDeletionHandler:yn,recoilValuesForKeys:ir,NodeMissingError:mn,DefaultValue:_n,DEFAULT_VALUE:ar,RecoilValueNotReady:sr};class Sn{}function hr(){return new Sn}var at={RetentionZone:Sn,retentionZone:hr};const{setByAddingToSet:pr}=fn,{getNode:st,getNodeMaybe:vr,recoilValuesForKeys:Rn}=he,{RetentionZone:gn}=at,_r=Object.freeze(new Set);class mr extends Error{}function yr(e,t,n){if(!G("recoil_memory_managament_2020"))return()=>{};const{nodesRetainedByZone:o}=e.getState().retention;function r(a){let i=o.get(a);i||o.set(a,i=new Set),i.add(t)}if(n instanceof gn)r(n);else if(Array.isArray(n))for(const a of n)r(a);return()=>{if(!G("recoil_memory_managament_2020"))return;const a=e.getState().retention.nodesRetainedByZone;function i(l){const f=a.get(l);f&&f.delete(t),f&&f.size===0&&a.delete(l)}if(n instanceof gn)i(n);else if(Array.isArray(n))for(const l of n)i(l)}}function Ut(e,t,n,o){const r=e.getState();if(r.nodeCleanupFunctions.has(n))return;const a=st(n),i=yr(e,n,a.retainedBy),l=a.init(e,t,o);r.nodeCleanupFunctions.set(n,()=>{l(),i()})}function Sr(e,t){var n;const o=e.getState();(n=o.nodeCleanupFunctions.get(t))===null||n===void 0||n(),o.nodeCleanupFunctions.delete(t)}function Rr(e,t,n){return Ut(e,t,n,"get"),st(n).get(e,t)}function bn(e,t,n){return st(n).peek(e,t)}function gr(e,t,n){var o;const r=vr(t);return r==null||(o=r.invalidate)===null||o===void 0||o.call(r,e),{...e,atomValues:e.atomValues.clone().delete(t),nonvalidatedAtoms:e.nonvalidatedAtoms.clone().set(t,n),dirtyAtoms:pr(e.dirtyAtoms,t)}}function br(e,t,n,o){const r=st(n);if(r.set==null)throw new mr(`Attempt to set read-only RecoilValue: ${n}`);const a=r.set;return Ut(e,t,n,"set"),a(e,t,o)}function wr(e,t,n){var o,r,a;const i=e.getState(),l=e.getGraph(t.version),f=i.knownAtoms.has(n)?"atom":i.knownSelectors.has(n)?"selector":void 0,h=dn(wn(e,t,new Set([n])),p=>p!==n);return{loadable:bn(e,t,n),isActive:i.knownAtoms.has(n)||i.knownSelectors.has(n),isSet:f==="selector"?!1:t.atomValues.has(n),isModified:t.dirtyAtoms.has(n),type:f,deps:Rn((o=l.nodeDeps.get(n))!==null&&o!==void 0?o:[]),subscribers:{nodes:Rn(h),components:hn((r=(a=i.nodeToComponentSubscriptions.get(n))===null||a===void 0?void 0:a.values())!==null&&r!==void 0?r:[],([p])=>({name:p}))}}}function wn(e,t,n){const o=new Set,r=Array.from(n),a=e.getGraph(t.version);for(let l=r.pop();l;l=r.pop()){var i;o.add(l);const f=(i=a.nodeToNodeSubscriptions.get(l))!==null&&i!==void 0?i:_r;for(const h of f)o.has(h)||r.push(h)}return o}var Ue={getNodeLoadable:Rr,peekNodeLoadable:bn,setNodeValue:br,cleanUpNode:Sr,setUnvalidatedAtomValue_DEPRECATED:gr,peekNodeInfo:wr,getDownstreamNodes:wn,initializeNodeIfNewToStore:Ut};const{CANCELED:Tr}=nt,{getDownstreamNodes:Ar,getNodeLoadable:Tn,setNodeValue:Er}=Ue,{getNodeMaybe:An}=he,{DefaultValue:It,RecoilValueNotReady:Nr}=he,{AbstractRecoilValue:Vr,RecoilState:Cr,RecoilValueReadOnly:Lr,isRecoilValue:$r}=Le;function Mr(e,{key:t},n=e.getState().currentTree){var o,r;const a=e.getState();!(n.version===a.currentTree.version||n.version===((o=a.nextTree)===null||o===void 0?void 0:o.version)||n.version===((r=a.previousTree)===null||r===void 0?void 0:r.version));const i=Tn(e,n,t);return i.state==="loading"&&i.contents.catch(()=>Tr),i}function Dr(e,t){const n=e.clone();return t.forEach((o,r)=>{o.state==="hasValue"&&o.contents instanceof It?n.delete(r):n.set(r,o)}),n}function kr(e,t,{key:n},o){if(typeof o=="function"){const r=Tn(e,t,n);if(r.state==="loading")throw new Nr(n);if(r.state==="hasError")throw r.contents;return o(r.contents)}else return o}function Ur(e,t,n){if(n.type==="set"){const{recoilValue:r,valueOrUpdater:a}=n,i=kr(e,t,r,a),l=Er(e,t,r.key,i);for(const[f,h]of l.entries())En(t,f,h)}else if(n.type==="setLoadable"){const{recoilValue:{key:r},loadable:a}=n;En(t,r,a)}else if(n.type==="markModified"){const{recoilValue:{key:r}}=n;t.dirtyAtoms.add(r)}else if(n.type==="setUnvalidated"){var o;const{recoilValue:{key:r},unvalidatedValue:a}=n,i=An(r);i==null||(o=i.invalidate)===null||o===void 0||o.call(i,t),t.atomValues.delete(r),t.nonvalidatedAtoms.set(r,a),t.dirtyAtoms.add(r)}else Ho(`Unknown action ${n.type}`)}function En(e,t,n){n.state==="hasValue"&&n.contents instanceof It?e.atomValues.delete(t):e.atomValues.set(t,n),e.dirtyAtoms.add(t),e.nonvalidatedAtoms.delete(t)}function Nn(e,t){e.replaceState(n=>{const o=Br(n);for(const r of t)Ur(e,o,r);return Vn(e,o),o})}function it(e,t){if(We.length){const n=We[We.length-1];let o=n.get(e);o||n.set(e,o=[]),o.push(t)}else Nn(e,[t])}const We=[];function Ir(){const e=new Map;return We.push(e),()=>{for(const[t,n]of e)Nn(t,n);We.pop()}}function Br(e){return{...e,atomValues:e.atomValues.clone(),nonvalidatedAtoms:e.nonvalidatedAtoms.clone(),dirtyAtoms:new Set(e.dirtyAtoms)}}function Vn(e,t){const n=Ar(e,t,t.dirtyAtoms);for(const a of n){var o,r;(o=An(a))===null||o===void 0||(r=o.invalidate)===null||r===void 0||r.call(o,t)}}function Cn(e,t,n){it(e,{type:"set",recoilValue:t,valueOrUpdater:n})}function Fr(e,t,n){if(n instanceof It)return Cn(e,t,n);it(e,{type:"setLoadable",recoilValue:t,loadable:n})}function Pr(e,t){it(e,{type:"markModified",recoilValue:t})}function xr(e,t,n){it(e,{type:"setUnvalidated",recoilValue:t,unvalidatedValue:n})}let Or=0;function zr(e,{key:t},n,o=null){const r=Or++,a=e.getState();return a.nodeToComponentSubscriptions.has(t)||a.nodeToComponentSubscriptions.set(t,new Map),I(a.nodeToComponentSubscriptions.get(t)).set(r,[o??"<not captured>",n]),{release:()=>{const i=e.getState(),l=i.nodeToComponentSubscriptions.get(t);l===void 0||!l.has(r)||(l.delete(r),l.size===0&&i.nodeToComponentSubscriptions.delete(t))}}}var Ie={RecoilValueReadOnly:Lr,AbstractRecoilValue:Vr,RecoilState:Cr,getRecoilValueAsLoadable:Mr,setRecoilValue:Cn,setRecoilValueLoadable:Fr,markRecoilValueModified:Pr,setUnvalidatedRecoilValue:xr,subscribeToRecoilValue:zr,isRecoilValue:$r,applyAtomValueWrites:Dr,batchStart:Ir,invalidateDownstreams_FOR_TESTING:Vn};const{unstable_batchedUpdates:Wr}=Bo;var Gr={unstable_batchedUpdates:Wr};const{unstable_batchedUpdates:Hr}=Gr;var Kr={unstable_batchedUpdates:Hr};const{batchStart:qr}=Ie,{unstable_batchedUpdates:Zr}=Kr;let Bt=Zr;const jr=e=>{Bt=e},Xr=()=>Bt,Yr=e=>{Bt(()=>{let t=()=>{};try{t=qr(),e()}finally{t()}})};var Ft={getBatcher:Xr,setBatcher:jr,batchUpdates:Yr};function Jr(e,t){t()}var Qr={enqueueExecution:Jr};function ea(e,...t){const n=new Set;e:for(const o of e){for(const r of t)if(r.has(o))continue e;n.add(o)}return n}var ct=ea;function ta(e,t){const n=new Map;return e.forEach((o,r)=>{n.set(r,t(o,r))}),n}var lt=ta;function na(){return{nodeDeps:new Map,nodeToNodeSubscriptions:new Map}}function oa(e){return{nodeDeps:lt(e.nodeDeps,t=>new Set(t)),nodeToNodeSubscriptions:lt(e.nodeToNodeSubscriptions,t=>new Set(t))}}function Pt(e,t,n){const{nodeDeps:o,nodeToNodeSubscriptions:r}=t;e.forEach((a,i)=>{const l=o.get(i);if(l&&n&&l!==n.nodeDeps.get(i))return;o.set(i,new Set(a)),(l==null?a:ct(a,l)).forEach(h=>{r.has(h)||r.set(h,new Set),I(r.get(h)).add(i)}),l&&ct(l,a).forEach(p=>{if(!r.has(p))return;const T=I(r.get(p));T.delete(i),T.size===0&&r.delete(p)})})}function ra(e,t,n){var o,r,a,i;const l=t.getState();!(n===l.currentTree.version||n===((o=l.nextTree)===null||o===void 0?void 0:o.version)||n===((r=l.previousTree)===null||r===void 0?void 0:r.version));const f=t.getGraph(n);if(Pt(e,f),n===((a=l.previousTree)===null||a===void 0?void 0:a.version)){const p=t.getGraph(l.currentTree.version);Pt(e,p,f)}if(n===((i=l.previousTree)===null||i===void 0?void 0:i.version)||n===l.currentTree.version){var h;const p=(h=l.nextTree)===null||h===void 0?void 0:h.version;if(p!==void 0){const T=t.getGraph(p);Pt(e,T,f)}}}function aa(e,t){e.forEach((n,o)=>{t.has(o)||t.set(o,new Set);const r=I(t.get(o));n.forEach(a=>r.add(a))})}function sa(e,t,n){n.has(e)||n.set(e,new Set),I(n.get(e)).add(t)}var Ge={addToDependencyMap:sa,cloneGraph:oa,graph:na,mergeDepsIntoDependencyMap:aa,saveDependencyMapToStore:ra};function ia(e,t){return t={exports:{}},e(t,t.exports),t.exports}var ca=ia(function(e){var t=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(c){return typeof c}:function(c){return c&&typeof Symbol=="function"&&c.constructor===Symbol&&c!==Symbol.prototype?"symbol":typeof c},n={},o=5,r=Math.pow(2,o),a=r-1,i=r/2,l=r/4,f={},h=function(s){return function(){return s}},p=n.hash=function(c){var s=typeof c=="undefined"?"undefined":t(c);if(s==="number")return c;s!=="string"&&(c+="");for(var d=0,m=0,y=c.length;m<y;++m){var R=c.charCodeAt(m);d=(d<<5)-d+R|0}return d},T=function(s){return s-=s>>1&1431655765,s=(s&858993459)+(s>>2&858993459),s=s+(s>>4)&252645135,s+=s>>8,s+=s>>16,s&127},U=function(s,d){return d>>>s&a},F=function(s){return 1<<s},A=function(s,d){return T(s&d-1)},B=function(s,d,m,y){var R=y;if(!s){var V=y.length;R=new Array(V);for(var E=0;E<V;++E)R[E]=y[E]}return R[d]=m,R},b=function(s,d,m){var y=m.length-1,R=0,V=0,E=m;if(s)R=V=d;else for(E=new Array(y);R<d;)E[V++]=m[R++];for(++R;R<=y;)E[V++]=m[R++];return s&&(E.length=y),E},D=function(s,d,m,y){var R=y.length;if(s){for(var V=R;V>=d;)y[V--]=y[V];return y[d]=m,y}for(var E=0,N=0,M=new Array(R+1);E<d;)M[N++]=y[E++];for(M[d]=m;E<R;)M[++N]=y[E++];return M},C=1,L=2,k=3,H=4,J={__hamt_isEmpty:!0},j=function(s){return s===J||s&&s.__hamt_isEmpty},K=function(s,d,m,y){return{type:C,edit:s,hash:d,key:m,value:y,_modify:me}},le=function(s,d,m){return{type:L,edit:s,hash:d,children:m,_modify:Ne}},be=function(s,d,m){return{type:k,edit:s,mask:d,children:m,_modify:ue}},we=function(s,d,m){return{type:H,edit:s,size:d,children:m,_modify:Ve}},ee=function(s){return s===J||s.type===C||s.type===L},Z=function(s,d,m,y,R){for(var V=[],E=y,N=0,M=0;E;++M)E&1&&(V[M]=R[N++]),E>>>=1;return V[d]=m,we(s,N+1,V)},Se=function(s,d,m,y){for(var R=new Array(d-1),V=0,E=0,N=0,M=y.length;N<M;++N)if(N!==m){var W=y[N];W&&!j(W)&&(R[V++]=W,E|=1<<N)}return be(s,E,R)},oe=function c(s,d,m,y,R,V){if(m===R)return le(s,m,[V,y]);var E=U(d,m),N=U(d,R);return be(s,F(E)|F(N),E===N?[c(s,d+o,m,y,R,V)]:E<N?[y,V]:[V,y])},_e=function(s,d,m,y,R,V,E,N){for(var M=R.length,W=0;W<M;++W){var ae=R[W];if(m(E,ae.key)){var Q=ae.value,ie=V(Q);return ie===Q?R:ie===f?(--N.value,b(s,W,R)):B(s,W,K(d,y,E,ie),R)}}var de=V();return de===f?R:(++N.value,B(s,M,K(d,y,E,de),R))},ne=function(s,d){return s===d.edit},me=function(s,d,m,y,R,V,E){if(d(V,this.key)){var N=y(this.value);return N===this.value?this:N===f?(--E.value,J):ne(s,this)?(this.value=N,this):K(s,R,V,N)}var M=y();return M===f?this:(++E.value,oe(s,m,this.hash,this,R,K(s,R,V,M)))},Ne=function(s,d,m,y,R,V,E){if(R===this.hash){var N=ne(s,this),M=_e(N,s,d,this.hash,this.children,y,V,E);return M===this.children?this:M.length>1?le(s,this.hash,M):M[0]}var W=y();return W===f?this:(++E.value,oe(s,m,this.hash,this,R,K(s,R,V,W)))},ue=function(s,d,m,y,R,V,E){var N=this.mask,M=this.children,W=U(m,R),ae=F(W),Q=A(N,ae),ie=N&ae,de=ie?M[Q]:J,De=de._modify(s,d,m+o,y,R,V,E);if(de===De)return this;var tt=ne(s,this),Oe=N,ze=void 0;if(ie&&j(De)){if(Oe&=~ae,!Oe)return J;if(M.length<=2&&ee(M[Q^1]))return M[Q^1];ze=b(tt,Q,M)}else if(!ie&&!j(De)){if(M.length>=i)return Z(s,W,De,N,M);Oe|=ae,ze=D(tt,Q,De,M)}else ze=B(tt,Q,De,M);return tt?(this.mask=Oe,this.children=ze,this):be(s,Oe,ze)},Ve=function(s,d,m,y,R,V,E){var N=this.size,M=this.children,W=U(m,R),ae=M[W],Q=(ae||J)._modify(s,d,m+o,y,R,V,E);if(ae===Q)return this;var ie=ne(s,this),de=void 0;if(j(ae)&&!j(Q))++N,de=B(ie,W,Q,M);else if(!j(ae)&&j(Q)){if(--N,N<=l)return Se(s,N,W,M);de=B(ie,W,J,M)}else de=B(ie,W,Q,M);return ie?(this.size=N,this.children=de,this):we(s,N,de)};J._modify=function(c,s,d,m,y,R,V){var E=m();return E===f?J:(++V.value,K(c,y,R,E))};function $(c,s,d,m,y){this._editable=c,this._edit=s,this._config=d,this._root=m,this._size=y}$.prototype.setTree=function(c,s){return this._editable?(this._root=c,this._size=s,this):c===this._root?this:new $(this._editable,this._edit,this._config,c,s)};var fe=n.tryGetHash=function(c,s,d,m){for(var y=m._root,R=0,V=m._config.keyEq;;)switch(y.type){case C:return V(d,y.key)?y.value:c;case L:{if(s===y.hash)for(var E=y.children,N=0,M=E.length;N<M;++N){var W=E[N];if(V(d,W.key))return W.value}return c}case k:{var ae=U(R,s),Q=F(ae);if(y.mask&Q){y=y.children[A(y.mask,Q)],R+=o;break}return c}case H:{if(y=y.children[U(R,s)],y){R+=o;break}return c}default:return c}};$.prototype.tryGetHash=function(c,s,d){return fe(c,s,d,this)};var Ce=n.tryGet=function(c,s,d){return fe(c,d._config.hash(s),s,d)};$.prototype.tryGet=function(c,s){return Ce(c,s,this)};var u=n.getHash=function(c,s,d){return fe(void 0,c,s,d)};$.prototype.getHash=function(c,s){return u(c,s,this)},n.get=function(c,s){return fe(void 0,s._config.hash(c),c,s)},$.prototype.get=function(c,s){return Ce(s,c,this)};var _=n.has=function(c,s,d){return fe(f,c,s,d)!==f};$.prototype.hasHash=function(c,s){return _(c,s,this)};var v=n.has=function(c,s){return _(s._config.hash(c),c,s)};$.prototype.has=function(c){return v(c,this)};var w=function(s,d){return s===d};n.make=function(c){return new $(0,0,{keyEq:c&&c.keyEq||w,hash:c&&c.hash||p},J,0)},n.empty=n.make();var g=n.isEmpty=function(c){return c&&!!j(c._root)};$.prototype.isEmpty=function(){return g(this)};var S=n.modifyHash=function(c,s,d,m){var y={value:m._size},R=m._root._modify(m._editable?m._edit:NaN,m._config.keyEq,0,c,s,d,y);return m.setTree(R,y.value)};$.prototype.modifyHash=function(c,s,d){return S(d,c,s,this)};var x=n.modify=function(c,s,d){return S(c,d._config.hash(s),s,d)};$.prototype.modify=function(c,s){return x(s,c,this)};var X=n.setHash=function(c,s,d,m){return S(h(d),c,s,m)};$.prototype.setHash=function(c,s,d){return X(c,s,d,this)};var Y=n.set=function(c,s,d){return X(d._config.hash(c),c,s,d)};$.prototype.set=function(c,s){return Y(c,s,this)};var O=h(f),z=n.removeHash=function(c,s,d){return S(O,c,s,d)};$.prototype.removeHash=$.prototype.deleteHash=function(c,s){return z(c,s,this)};var re=n.remove=function(c,s){return z(s._config.hash(c),c,s)};$.prototype.remove=$.prototype.delete=function(c){return re(c,this)};var Me=n.beginMutation=function(c){return new $(c._editable+1,c._edit+1,c._config,c._root,c._size)};$.prototype.beginMutation=function(){return Me(this)};var Re=n.endMutation=function(c){return c._editable=c._editable&&c._editable-1,c};$.prototype.endMutation=function(){return Re(this)};var ye=n.mutate=function(c,s){var d=Me(s);return c(d),Re(d)};$.prototype.mutate=function(c){return ye(c,this)};var se=function(s){return s&&xe(s[0],s[1],s[2],s[3],s[4])},xe=function(s,d,m,y,R){for(;m<s;){var V=d[m++];if(V&&!j(V))return cn(V,y,[s,d,m,y,R])}return se(R)},cn=function(s,d,m){switch(s.type){case C:return{value:d(s),rest:m};case L:case H:case k:var y=s.children;return xe(y.length,y,0,d,m);default:return se(m)}},Vo={done:!0};function Et(c){this.v=c}Et.prototype.next=function(){if(!this.v)return Vo;var c=this.v;return this.v=se(c.rest),c},Et.prototype[Symbol.iterator]=function(){return this};var Nt=function(s,d){return new Et(cn(s._root,d))},Co=function(s){return[s.key,s.value]},Lo=n.entries=function(c){return Nt(c,Co)};$.prototype.entries=$.prototype[Symbol.iterator]=function(){return Lo(this)};var $o=function(s){return s.key},Mo=n.keys=function(c){return Nt(c,$o)};$.prototype.keys=function(){return Mo(this)};var Do=function(s){return s.value},ko=n.values=$.prototype.values=function(c){return Nt(c,Do)};$.prototype.values=function(){return ko(this)};var ln=n.fold=function(c,s,d){var m=d._root;if(m.type===C)return c(s,m.value,m.key);for(var y=[m.children],R=void 0;R=y.pop();)for(var V=0,E=R.length;V<E;){var N=R[V++];N&&N.type&&(N.type===C?s=c(s,N.value,N.key):y.push(N.children))}return s};$.prototype.fold=function(c,s){return ln(c,s,this)};var Uo=n.forEach=function(c,s){return ln(function(d,m,y){return c(m,y,s)},null,s)};$.prototype.forEach=function(c){return Uo(c,this)};var Io=n.count=function(c){return c._size};$.prototype.count=function(){return Io(this)},Object.defineProperty($.prototype,"size",{get:$.prototype.count}),e.exports?e.exports=n:(void 0).hamt=n});class la{constructor(t){P(this,"_map",void 0),this._map=new Map(t==null?void 0:t.entries())}keys(){return this._map.keys()}entries(){return this._map.entries()}get(t){return this._map.get(t)}has(t){return this._map.has(t)}set(t,n){return this._map.set(t,n),this}delete(t){return this._map.delete(t),this}clone(){return Ot(this)}toMap(){return new Map(this._map)}}class xt{constructor(t){if(P(this,"_hamt",ca.empty.beginMutation()),t instanceof xt){const n=t._hamt.endMutation();t._hamt=n.beginMutation(),this._hamt=n.beginMutation()}else if(t)for(const[n,o]of t.entries())this._hamt.set(n,o)}keys(){return this._hamt.keys()}entries(){return this._hamt.entries()}get(t){return this._hamt.get(t)}has(t){return this._hamt.has(t)}set(t,n){return this._hamt.set(t,n),this}delete(t){return this._hamt.delete(t),this}clone(){return Ot(this)}toMap(){return new Map(this._hamt)}}function Ot(e){return G("recoil_hamt_2020")?new xt(e):new la(e)}var ua={persistentMap:Ot},fa=ua.persistentMap,da=Object.freeze({__proto__:null,persistentMap:fa});const{graph:ha}=Ge,{persistentMap:Ln}=da;let pa=0;const $n=()=>pa++;function Mn(){const e=$n();return{version:e,stateID:e,transactionMetadata:{},dirtyAtoms:new Set,atomValues:Ln(),nonvalidatedAtoms:Ln()}}function va(){const e=Mn();return{currentTree:e,nextTree:null,previousTree:null,commitDepth:0,knownAtoms:new Set,knownSelectors:new Set,transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:new Map().set(e.version,ha()),versionsUsedByComponent:new Map,retention:{referenceCounts:new Map,nodesRetainedByZone:new Map,retainablesToCheckForRelease:new Set},nodeCleanupFunctions:new Map}}var Dn={makeEmptyTreeState:Mn,makeEmptyStoreState:va,getNextTreeStateVersion:$n};function _a(...e){const t=new Set;for(const n of e)for(const o of n)t.add(o);return t}var ma=_a;function ya(e,t,n){const o=e.entries();let r=o.next();for(;!r.done;){const a=r.value;if(t.call(n,a[1],a[0],e))return!0;r=o.next()}return!1}var Sa=ya;const{cleanUpNode:Ra}=Ue,{deleteNodeConfigIfPossible:ga,getNode:kn}=he,{RetentionZone:Un}=at,In=new Set;function Bn(e,t){const n=e.getState(),o=n.currentTree;if(n.nextTree)return;const r=new Set;for(const i of t)if(i instanceof Un)for(const l of Aa(n,i))r.add(l);else r.add(i);const a=ba(e,r);for(const i of a)Ta(e,o,i)}function ba(e,t){const n=e.getState(),o=n.currentTree,r=e.getGraph(o.version),a=new Set,i=new Set;return l(t),a;function l(f){const h=new Set,p=wa(e,o,f,a,i);for(const A of p){var T;if(kn(A).retainedBy==="recoilRoot"){i.add(A);continue}if(((T=n.retention.referenceCounts.get(A))!==null&&T!==void 0?T:0)>0){i.add(A);continue}if(Fn(A).some(b=>n.retention.referenceCounts.get(b))){i.add(A);continue}const B=r.nodeToNodeSubscriptions.get(A);if(B&&Sa(B,b=>i.has(b))){i.add(A);continue}a.add(A),h.add(A)}const U=new Set;for(const A of h)for(const B of(F=r.nodeDeps.get(A))!==null&&F!==void 0?F:In){var F;a.has(B)||U.add(B)}U.size&&l(U)}}function wa(e,t,n,o,r){const a=e.getGraph(t.version),i=[],l=new Set;for(;n.size>0;)f(I(n.values().next().value));return i;function f(h){if(o.has(h)||r.has(h)){n.delete(h);return}if(l.has(h))return;const p=a.nodeToNodeSubscriptions.get(h);if(p)for(const T of p)f(T);l.add(h),n.delete(h),i.push(h)}}function Ta(e,t,n){if(!G("recoil_memory_managament_2020"))return;Ra(e,n);const o=e.getState();o.knownAtoms.delete(n),o.knownSelectors.delete(n),o.nodeTransactionSubscriptions.delete(n),o.retention.referenceCounts.delete(n);const r=Fn(n);for(const f of r){var a;(a=o.retention.nodesRetainedByZone.get(f))===null||a===void 0||a.delete(n)}t.atomValues.delete(n),t.dirtyAtoms.delete(n),t.nonvalidatedAtoms.delete(n);const i=o.graphsByVersion.get(t.version);if(i){const f=i.nodeDeps.get(n);if(f!==void 0){i.nodeDeps.delete(n);for(const h of f){var l;(l=i.nodeToNodeSubscriptions.get(h))===null||l===void 0||l.delete(n)}}i.nodeToNodeSubscriptions.delete(n)}ga(n)}function Aa(e,t){var n;return(n=e.retention.nodesRetainedByZone.get(t))!==null&&n!==void 0?n:In}function Fn(e){const t=kn(e).retainedBy;return t===void 0||t==="components"||t==="recoilRoot"?[]:t instanceof Un?[t]:t}function Ea(e,t){const n=e.getState();n.nextTree?n.retention.retainablesToCheckForRelease.add(t):Bn(e,new Set([t]))}function Na(e,t,n){var o;if(!G("recoil_memory_managament_2020"))return;const r=e.getState().retention.referenceCounts,a=((o=r.get(t))!==null&&o!==void 0?o:0)+n;a===0?Pn(e,t):r.set(t,a)}function Pn(e,t){if(!G("recoil_memory_managament_2020"))return;e.getState().retention.referenceCounts.delete(t),Ea(e,t)}function Va(e){if(!G("recoil_memory_managament_2020"))return;const t=e.getState();Bn(e,t.retention.retainablesToCheckForRelease),t.retention.retainablesToCheckForRelease.clear()}function Ca(e){return e===void 0?"recoilRoot":e}var He={updateRetainCount:Na,updateRetainCountToZero:Pn,releaseScheduledRetainablesNow:Va,retainedByOptionWithDefault:Ca};function*La(e){for(const t of e)for(const n of t)yield n}var $a=La;const Ma=typeof window=="undefined",Da=typeof navigator!="undefined"&&navigator.product==="ReactNative";var xn={isSSR:Ma,isReactNative:Da};const{isSSR:ka}=xn,{batchUpdates:zt}=Ft,{initializeNodeIfNewToStore:Ua,peekNodeInfo:Ia}=Ue,{graph:Ba}=Ge,{DEFAULT_VALUE:Fa,recoilValues:On,recoilValuesForKeys:zn}=he,{AbstractRecoilValue:Pa,getRecoilValueAsLoadable:xa,setRecoilValue:Wn,setUnvalidatedRecoilValue:Oa}=Ie,{updateRetainCount:ut,updateRetainCountToZero:al}=He,{getNextTreeStateVersion:za,makeEmptyStoreState:Wa}=Dn;class ft{constructor(t){P(this,"_store",void 0),P(this,"_refCount",0),P(this,"getLoadable",n=>(this.checkRefCount_INTERNAL(),xa(this._store,n))),P(this,"getPromise",n=>(this.checkRefCount_INTERNAL(),this.getLoadable(n).toPromise())),P(this,"getNodes_UNSTABLE",n=>{if(this.checkRefCount_INTERNAL(),(n==null?void 0:n.isModified)===!0){if((n==null?void 0:n.isInitialized)===!1)return[];const a=this._store.getState().currentTree;return zn(a.dirtyAtoms)}const o=this._store.getState().knownAtoms,r=this._store.getState().knownSelectors;return(n==null?void 0:n.isInitialized)==null?On.values():n.isInitialized===!0?zn($a([this._store.getState().knownAtoms,this._store.getState().knownSelectors])):dn(On.values(),({key:a})=>!o.has(a)&&!r.has(a))}),P(this,"getInfo_UNSTABLE",({key:n})=>(this.checkRefCount_INTERNAL(),Ia(this._store,this._store.getState().currentTree,n))),P(this,"map",n=>{this.checkRefCount_INTERNAL();const o=new Gt(this);return n(o),Wt(o.getStore_INTERNAL())}),P(this,"asyncMap",async n=>{this.checkRefCount_INTERNAL();const o=new Gt(this);return await n(o),Wt(o.getStore_INTERNAL())}),this._store={getState:()=>t,replaceState:n=>{t.currentTree=n(t.currentTree)},getGraph:n=>{const o=t.graphsByVersion;if(o.has(n))return I(o.get(n));const r=Ba();return o.set(n,r),r},subscribeToTransactions:()=>({release:()=>{}}),addTransactionMetadata:()=>{throw new Error("Cannot subscribe to Snapshots")}};for(const n of this._store.getState().nodeCleanupFunctions.keys())Ua(this._store,t.currentTree,n,"get"),ut(this._store,n,1);this.retain(),this.autorelease_INTERNAL()}retain(){if(!G("recoil_memory_managament_2020"))return()=>{};this._refCount++;let t=!1;return()=>{t||(t=!0,this.release_INTERNAL())}}autorelease_INTERNAL(){!G("recoil_memory_managament_2020")||ka||window.setTimeout(()=>this.release_INTERNAL(),0)}release_INTERNAL(){!G("recoil_memory_managament_2020")||(this._refCount--,this._refCount===0)}checkRefCount_INTERNAL(){G("recoil_memory_managament_2020")&&this._refCount<=0}getStore_INTERNAL(){return this.checkRefCount_INTERNAL(),this._store}getID(){return this.checkRefCount_INTERNAL(),this.getID_INTERNAL()}getID_INTERNAL(){return this.checkRefCount_INTERNAL(),this._store.getState().currentTree.stateID}}function Gn(e,t,n=!1){const o=e.getState(),r=n?za():t.version;return{currentTree:n?{version:r,stateID:r,transactionMetadata:{...t.transactionMetadata},dirtyAtoms:new Set(t.dirtyAtoms),atomValues:t.atomValues.clone(),nonvalidatedAtoms:t.nonvalidatedAtoms.clone()}:t,commitDepth:0,nextTree:null,previousTree:null,knownAtoms:new Set(o.knownAtoms),knownSelectors:new Set(o.knownSelectors),transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:new Map().set(r,e.getGraph(t.version)),versionsUsedByComponent:new Map,retention:{referenceCounts:new Map,nodesRetainedByZone:new Map,retainablesToCheckForRelease:new Set},nodeCleanupFunctions:new Map}}function Ga(e){const t=new ft(Wa());return e!=null?t.map(e):t}function Wt(e,t="current"){const n=e.getState(),o=t==="current"?n.currentTree:I(n.previousTree);return new ft(Gn(e,o))}class Gt extends ft{constructor(t){super(Gn(t.getStore_INTERNAL(),t.getStore_INTERNAL().getState().currentTree,!0));P(this,"set",(n,o)=>{this.checkRefCount_INTERNAL();const r=this.getStore_INTERNAL();zt(()=>{ut(r,n.key,1),Wn(this.getStore_INTERNAL(),n,o)})}),P(this,"reset",n=>{this.checkRefCount_INTERNAL();const o=this.getStore_INTERNAL();zt(()=>{ut(o,n.key,1),Wn(this.getStore_INTERNAL(),n,Fa)})}),P(this,"setUnvalidatedAtomValues_DEPRECATED",n=>{this.checkRefCount_INTERNAL();const o=this.getStore_INTERNAL();zt(()=>{for(const[r,a]of n.entries())ut(o,r,1),Oa(o,new Pa(r),a)})})}}var dt={Snapshot:ft,MutableSnapshot:Gt,freshSnapshot:Ga,cloneSnapshot:Wt},Ha=dt.Snapshot,Ka=dt.MutableSnapshot,qa=dt.freshSnapshot,Za=dt.cloneSnapshot,ht=Object.freeze({__proto__:null,Snapshot:Ha,MutableSnapshot:Ka,freshSnapshot:qa,cloneSnapshot:Za});const{getNextTreeStateVersion:ja,makeEmptyStoreState:Hn}=Dn,{cleanUpNode:Xa,getDownstreamNodes:Ya,setNodeValue:Ja,setUnvalidatedAtomValue_DEPRECATED:Qa}=Ue,{graph:es}=Ge,{cloneGraph:ts}=Ge,{applyAtomValueWrites:ns}=Ie,{releaseScheduledRetainablesNow:Kn}=He,{freshSnapshot:os}=ht,{useCallback:rs,useContext:qn,useEffect:Ht,useMemo:as,useRef:Kt,useState:ss}=te;function Ke(){throw new Error("This component must be used inside a <RecoilRoot> component.")}const Zn=Object.freeze({getState:Ke,replaceState:Ke,getGraph:Ke,subscribeToTransactions:Ke,addTransactionMetadata:Ke});let qt=!1;function jn(e){if(qt)throw new Error("An atom update was triggered within the execution of a state updater function. State updater functions provided to Recoil must be pure functions.");const t=e.getState();if(t.nextTree===null){G("recoil_memory_managament_2020")&&G("recoil_release_on_cascading_update_killswitch_2021")&&t.commitDepth>0&&Kn(e);const n=t.currentTree.version,o=ja();t.nextTree={...t.currentTree,version:o,stateID:o,dirtyAtoms:new Set,transactionMetadata:{}},t.graphsByVersion.set(o,ts(I(t.graphsByVersion.get(n))))}}const Xn=te.createContext({current:Zn}),Zt=()=>qn(Xn),Yn=te.createContext(null);function is(){return qn(Yn)}function Jn(e){const t=e.getState(),n=t.currentTree,o=n.dirtyAtoms;if(o.size){for(const[a,i]of t.nodeTransactionSubscriptions)if(o.has(a))for(const[l,f]of i)f(e);for(const[a,i]of t.transactionSubscriptions)i(e);const r=Ya(e,n,o);for(const a of r){const i=t.nodeToComponentSubscriptions.get(a);if(i)for(const[l,[f,h]]of i)h(n)}t.suspendedComponentResolvers.forEach(a=>a())}t.queuedComponentCallbacks_DEPRECATED.forEach(r=>r(n)),t.queuedComponentCallbacks_DEPRECATED.splice(0,t.queuedComponentCallbacks_DEPRECATED.length)}function cs({setNotifyBatcherOfChange:e}){const t=Zt(),[n,o]=ss([]);return e(()=>o({})),Ht(()=>{Qr.enqueueExecution("Batcher",()=>{const r=t.current.getState();r.commitDepth++;try{const{nextTree:a}=r;if(a===null)return;r.previousTree=r.currentTree,r.currentTree=a,r.nextTree=null,Jn(t.current);const i=I(r.previousTree).version;r.graphsByVersion.delete(i),r.previousTree=null,G("recoil_memory_managament_2020")&&Kn(t.current)}finally{r.commitDepth--}})}),Ht(()=>()=>{e(()=>{})},[e]),null}function ls(e,t){const n=Hn();return t({set:(o,r)=>{const a=n.currentTree,i=Ja(e,a,o.key,r),l=new Set(i.keys()),f=a.nonvalidatedAtoms.clone();for(const h of l)f.delete(h);n.currentTree={...a,dirtyAtoms:ma(a.dirtyAtoms,l),atomValues:ns(a.atomValues,i),nonvalidatedAtoms:f}},setUnvalidatedAtomValues:o=>{o.forEach((r,a)=>{n.currentTree=Qa(n.currentTree,a,r)})}}),n}function us(e){return os().map(e).getStore_INTERNAL().getState()}let Qn=0;function fs({initializeState_DEPRECATED:e,initializeState:t,store_INTERNAL:n,children:o}){var r;let a;const i=b=>{const D=a.current.graphsByVersion;if(D.has(b))return I(D.get(b));const C=es();return D.set(b,C),C},l=(b,D)=>{if(D==null){const{transactionSubscriptions:C}=A.current.getState(),L=Qn++;return C.set(L,b),{release:()=>{C.delete(L)}}}else{const{nodeTransactionSubscriptions:C}=A.current.getState();C.has(D)||C.set(D,new Map);const L=Qn++;return I(C.get(D)).set(L,b),{release:()=>{const k=C.get(D);k&&(k.delete(L),k.size===0&&C.delete(D))}}}},f=b=>{jn(A.current);for(const D of Object.keys(b))I(A.current.getState().nextTree).transactionMetadata[D]=b[D]},h=b=>{const D=A.current.getState();jn(A.current);const C=I(D.nextTree);let L;try{qt=!0,L=b(C)}finally{qt=!1}L!==C&&(D.nextTree=L,I(p.current)())},p=Kt(null),T=rs(b=>{p.current=b},[p]),U=(r=te.createMutableSource)!==null&&r!==void 0?r:te.unstable_createMutableSource,F=n??{getState:()=>a.current,replaceState:h,getGraph:i,subscribeToTransactions:l,addTransactionMetadata:f},A=Kt(F);a=Kt(e!=null?ls(F,e):t!=null?us(t):Hn());const B=as(()=>U?U(a,()=>a.current.currentTree.version):null,[U,a]);return Ht(()=>()=>{for(const b of A.current.getState().knownAtoms)Xa(A.current,b)},[]),te.createElement(Xn.Provider,{value:A},te.createElement(Yn.Provider,{value:B},te.createElement(cs,{setNotifyBatcherOfChange:T}),o))}function ds(e){const{override:t,...n}=e,o=Zt();return t===!1&&o.current!==Zn?te.createElement(te.Fragment,null,e.children):te.createElement(fs,n)}var pt={useStoreRef:Zt,useRecoilMutableSource:is,RecoilRoot:ds,sendEndOfBatchNotifications_FOR_TESTING:Jn};function hs(e,t){const n=new Map;for(const[o,r]of e)t(r,o)&&n.set(o,r);return n}var ps=hs;function vs(e,t){const n=new Set;for(const o of e)t(o)&&n.add(o);return n}var _s=vs;function ms(e,t){if(!e)throw new Error(t)}var ys=ms,vt=ys;function Ss(...e){const t=new Map;for(let n=0;n<e.length;n++){const o=e[n].keys();let r;for(;!(r=o.next()).done;)t.set(r.value,e[n].get(r.value))}return t}var Rs=Ss,jt;const eo=(jt=te.useMutableSource)!==null&&jt!==void 0?jt:te.unstable_useMutableSource;function gs(){return eo&&!(typeof window!="undefined"&&window.$disableRecoilValueMutableSource_TEMP_HACK_DO_NOT_USE)}var bs={mutableSourceExists:gs,useMutableSource:eo};function ws(e,t){if(e===t)return!0;if(e.length!==t.length)return!1;for(let n=0,o=e.length;n<o;n++)if(e[n]!==t[n])return!1;return!0}var Ts=ws;const{useRef:As}=te;function Es(){return As(),"<component name not available>"}var Xt=Es;const{batchUpdates:Yt}=Ft,{DEFAULT_VALUE:_t,getNode:to,nodes:Ns}=he,{useRecoilMutableSource:Vs,useStoreRef:ce}=pt,{AbstractRecoilValue:Jt,getRecoilValueAsLoadable:qe,setRecoilValue:Be,setRecoilValueLoadable:Cs,setUnvalidatedRecoilValue:Ls,subscribeToRecoilValue:Qt}=Ie,{updateRetainCount:Ze}=He,{RetentionZone:$s}=at,{Snapshot:sl,cloneSnapshot:je}=ht,{setByAddingToSet:Ms}=fn,{isSSR:mt}=xn,{mutableSourceExists:Ds,useMutableSource:ks}=bs,{useCallback:pe,useEffect:ge,useMemo:Us,useRef:Te,useState:en}=te,no=12e4;function oo(e,t,n){if(e.state==="hasValue")return e.contents;throw e.state==="loading"?new Promise(r=>{n.current.getState().suspendedComponentResolvers.add(r)}):e.state==="hasError"?e.contents:new Error(`Invalid value of loadable atom "${t.key}"`)}function Is(){const e=ce(),[t,n]=en([]),o=Te(new Set);o.current=new Set;const r=Te(new Set),a=Te(new Map),i=pe(f=>{const h=a.current.get(f);h&&(h.release(),a.current.delete(f))},[a]),l=Xt();return ge(()=>{const f=e.current;function h(p,T){!a.current.has(T)||n([])}ct(o.current,r.current).forEach(p=>{if(a.current.has(p))return;const T=Qt(f,new Jt(p),F=>{h(F,p)},l);a.current.set(p,T),f.getState().nextTree?f.getState().queuedComponentCallbacks_DEPRECATED.push(()=>{h(f.getState(),p)}):h(f.getState(),p)}),ct(r.current,o.current).forEach(p=>{i(p)}),r.current=o.current}),ge(()=>{const f=a.current;return()=>f.forEach((h,p)=>i(p))},[i]),Us(()=>{function f(A){return B=>{Be(e.current,A,B)}}function h(A){return()=>Be(e.current,A,_t)}function p(A){return o.current.has(A.key)||(o.current=Ms(o.current,A.key)),qe(e.current,A)}function T(A){const B=p(A);return oo(B,A,e)}function U(A){return[T(A),f(A)]}function F(A){return[p(A),f(A)]}return{getRecoilValue:T,getRecoilValueLoadable:p,getRecoilState:U,getRecoilStateLoadable:F,getSetRecoilState:f,getResetRecoilState:h}},[o,e])}const Bs={current:0};function Fs(e){const t=ce(),n=pe(()=>{const h=t.current,p=h.getState().currentTree;return qe(h,e,p)},[t,e]),o=pe(()=>n(),[n]),r=Xt(),a=pe((h,p)=>{const T=t.current;return Qt(T,e,()=>{if(!G("recoil_suppress_rerender_in_callback"))return p();const F=n();f.current.is(F)||p(),f.current=F},r).release},[t,e,r,n]),i=Vs(),l=ks(i,o,a),f=Te(l);return ge(()=>{f.current=l}),l}function Ps(e){const t=ce(),[n,o]=en([]),r=Xt();ge(()=>{const l=t.current,f=l.getState(),h=Qt(l,e,T=>{var U;if(!G("recoil_suppress_rerender_in_callback"))return o([]);const F=qe(l,e,l.getState().currentTree);((U=i.current)===null||U===void 0?void 0:U.is(F))||o(F),i.current=F},r);if(f.nextTree)l.getState().queuedComponentCallbacks_DEPRECATED.push(()=>{i.current=null,o([])});else{var p;if(!G("recoil_suppress_rerender_in_callback"))return o([]);const T=qe(l,e,l.getState().currentTree);((p=i.current)===null||p===void 0?void 0:p.is(T))||o(T),i.current=T}return h.release},[r,e,t]);const a=qe(t.current,e),i=Te(a);return ge(()=>{i.current=a}),a}function tn(e){return G("recoil_memory_managament_2020")&&lo(e),Ds()?Fs(e):Ps(e)}function ro(e){const t=ce(),n=tn(e);return oo(n,e,t)}function nn(e){const t=ce();return pe(n=>{Be(t.current,e,n)},[t,e])}function xs(e){const t=ce();return pe(()=>{Be(t.current,e,_t)},[t,e])}function Os(e){return[ro(e),nn(e)]}function zs(e){return[tn(e),nn(e)]}function yt(e){const t=ce();ge(()=>t.current.subscribeToTransactions(e).release,[e,t])}function ao(e){const t=e.atomValues.toMap(),n=lt(ps(t,(o,r)=>{const i=to(r).persistence_UNSTABLE;return i!=null&&i.type!=="none"&&o.state==="hasValue"}),o=>o.contents);return Rs(e.nonvalidatedAtoms.toMap(),n)}function Ws(e){yt(pe(t=>{let n=t.getState().previousTree;const o=t.getState().currentTree;n||(n=t.getState().currentTree);const r=ao(o),a=ao(n),i=lt(Ns,f=>{var h,p,T,U;return{persistence_UNSTABLE:{type:(h=(p=f.persistence_UNSTABLE)===null||p===void 0?void 0:p.type)!==null&&h!==void 0?h:"none",backButton:(T=(U=f.persistence_UNSTABLE)===null||U===void 0?void 0:U.backButton)!==null&&T!==void 0?T:!1}}}),l=_s(o.dirtyAtoms,f=>r.has(f)||a.has(f));e({atomValues:r,previousAtomValues:a,atomInfo:i,modifiedAtoms:l,transactionMetadata:{...o.transactionMetadata}})},[e]))}function Gs(e){yt(pe(t=>{const n=je(t,"current"),o=je(t,"previous");e({snapshot:n,previousSnapshot:o})},[e]))}function so(e){const t=Te();return ge(()=>{t.current=e}),t.current}function Hs(){const e=ce(),[t,n]=en(()=>je(e.current)),o=so(t),r=Te();return ge(()=>(r.current&&!mt&&window.clearTimeout(r.current),t.retain()),[t]),yt(pe(a=>n(je(a)),[])),o!==t&&!mt&&(r.current&&(o==null||o.release_INTERNAL(),window.clearTimeout(r.current)),t.retain(),r.current=window.setTimeout(()=>{t.release_INTERNAL(),r.current=null},no)),t}function io(){const e=ce();return pe(t=>{var n;const o=e.current.getState(),r=(n=o.nextTree)!==null&&n!==void 0?n:o.currentTree,a=t.getStore_INTERNAL().getState().currentTree;Yt(()=>{const i=new Set;for(const h of[r.atomValues.keys(),a.atomValues.keys()])for(const p of h){var l,f;((l=r.atomValues.get(p))===null||l===void 0?void 0:l.contents)!==((f=a.atomValues.get(p))===null||f===void 0?void 0:f.contents)&&to(p).shouldRestoreFromSnapshots&&i.add(p)}i.forEach(h=>{Cs(e.current,new Jt(h),a.atomValues.has(h)?I(a.atomValues.get(h)):_t)}),e.current.replaceState(h=>({...h,stateID:t.getID_INTERNAL()}))})},[e])}function Ks(){const e=ce();return(t,n={})=>{Yt(()=>{e.current.addTransactionMetadata(n),t.forEach((o,r)=>Ls(e.current,new Jt(r),o))})}}class co{}const qs=new co;function Zs(e,t){const n=ce(),o=io();return pe((...r)=>{function a(h,p){Be(n.current,h,p)}function i(h){Be(n.current,h,_t)}const l=je(n.current);let f=qs;return Yt(()=>{const h="useRecoilCallback expects a function that returns a function: it accepts a function of the type (RecoilInterface) => T = R and returns a callback function T => R, where RecoilInterface is an object {snapshot, set, ...} and T and R are the argument and return types of the callback you want to create.  Please see the docs at recoiljs.org for details.";if(typeof e!="function")throw new Error(h);const p=e({set:a,reset:i,snapshot:l,gotoSnapshot:o});if(typeof p!="function")throw new Error(h);f=p(...r)}),f instanceof co&&vt(!1),f},t!=null?[...t,n]:void 0)}function lo(e){if(!!G("recoil_memory_managament_2020"))return js(e)}function js(e){const n=(Array.isArray(e)?e:[e]).map(i=>i instanceof $s?i:i.key),o=ce();ge(()=>{if(!G("recoil_memory_managament_2020"))return;const i=o.current;if(r.current&&!mt)window.clearTimeout(r.current),r.current=null;else for(const l of n)Ze(i,l,1);return()=>{for(const l of n)Ze(i,l,-1)}},[o,...n]);const r=Te(),a=so(n);if(!mt&&(a===void 0||!Ts(a,n))){const i=o.current;for(const l of n)Ze(i,l,1);if(a)for(const l of a)Ze(i,l,-1);r.current&&window.clearTimeout(r.current),r.current=window.setTimeout(()=>{r.current=null;for(const l of n)Ze(i,l,-1)},no)}}var Xs={recoilComponentGetRecoilValueCount_FOR_TESTING:Bs,useGotoRecoilSnapshot:io,useRecoilCallback:Zs,useRecoilInterface:Is,useRecoilSnapshot:Hs,useRecoilState:Os,useRecoilStateLoadable:zs,useRecoilTransactionObserver:Gs,useRecoilValue:ro,useRecoilValueLoadable:tn,useRetain:lo,useResetRecoilState:xs,useSetRecoilState:nn,useSetUnvalidatedAtomValues:Ks,useTransactionObservation_DEPRECATED:Ws,useTransactionSubscription_DEPRECATED:yt};const{peekNodeInfo:Ys}=Ue,{useStoreRef:Js}=pt;function Qs(){const e=Js();return({key:t})=>Ys(e.current,e.current.getState().currentTree,t)}var ei=Qs;const{RecoilRoot:ti,useStoreRef:ni}=pt,{useMemo:oi}=te;function ri(){const e=ni().current;return oi(()=>{function t({children:n}){return te.createElement(ti,{store_INTERNAL:e},n)}return t},[e])}var ai=ri;function ve(e,t,n){if(typeof e=="string"&&!e.includes('"')&&!e.includes("\\"))return`"${e}"`;switch(typeof e){case"undefined":return"";case"boolean":return e?"true":"false";case"number":case"symbol":return String(e);case"string":return JSON.stringify(e);case"function":if((t==null?void 0:t.allowFunctions)!==!0)throw new Error("Attempt to serialize function in a Recoil cache key");return`__FUNCTION(${e.name})__`}if(e===null)return"null";if(typeof e!="object"){var o;return(o=JSON.stringify(e))!==null&&o!==void 0?o:""}if(q(e))return"__PROMISE__";if(Array.isArray(e))return`[${e.map((r,a)=>ve(r,t,a.toString()))}]`;if(typeof e.toJSON=="function")return ve(e.toJSON(n),t,n);if(e instanceof Map){const r={};for(const[a,i]of e)r[typeof a=="string"?a:ve(a,t)]=i;return ve(r,t,n)}return e instanceof Set?ve(Array.from(e).sort((r,a)=>ve(r,t).localeCompare(ve(a,t))),t,n):Symbol!==void 0&&e[Symbol.iterator]!=null&&typeof e[Symbol.iterator]=="function"?ve(Array.from(e),t,n):`{${Object.keys(e).filter(r=>e[r]!==void 0).sort().map(r=>`${ve(r,t)}:${ve(e[r],t,r)}`).join(",")}}`}function si(e,t={allowFunctions:!1}){return ve(e,t)}var St=si;class ii{constructor(t){var n,o,r;P(this,"_numLeafs",void 0),P(this,"_root",void 0),P(this,"_onHit",void 0),P(this,"_onSet",void 0),P(this,"_mapNodeValue",void 0),this._numLeafs=0,this._root=null,this._onHit=(n=t==null?void 0:t.onHit)!==null&&n!==void 0?n:()=>{},this._onSet=(o=t==null?void 0:t.onSet)!==null&&o!==void 0?o:()=>{},this._mapNodeValue=(r=t==null?void 0:t.mapNodeValue)!==null&&r!==void 0?r:a=>a}size(){return this._numLeafs}root(){return this._root}get(t,n){var o;return(o=this.getLeafNode(t,n))===null||o===void 0?void 0:o.value}getLeafNode(t,n){return uo(this.root(),o=>this._mapNodeValue(t(o)),{onNodeVisit:o=>{n==null||n.onNodeVisit(o),o.type==="leaf"&&this._onHit(o)}})}set(t,n,o){let r;const a=on(this.root(),t.map(([i,l])=>[i,this._mapNodeValue(l)]),null,n,null,{onNodeVisit:i=>{o==null||o.onNodeVisit(i),i.type==="leaf"&&(r=i)}});this.root()||(this._root=a),this._numLeafs++,this._onSet(I(r))}delete(t){if(!this.root())return!1;const n=I(this.root());return ci(n,t,t.parent)?t===n||n.type==="branch"&&!n.branches.size?(this._root=null,this._numLeafs=0,!0):(this._numLeafs-=ho(t),!0):!1}clear(){this._numLeafs=0,this._root=null}}const uo=(e,t,n)=>{var o;if(e==null)return;if(n==null||(o=n.onNodeVisit)===null||o===void 0||o.call(n,e),e.type==="leaf")return e;const r=t(e.nodeKey);return uo(e.branches.get(r),t,n)},on=(e,t,n,o,r,a)=>{var i;let l;if(e==null)if(t.length===0)l={type:"leaf",value:o,parent:n,branchKey:r};else{const[f,...h]=t,[p,T]=f;l={type:"branch",nodeKey:p,parent:n,branches:new Map,branchKey:r},l.branches.set(T,on(null,h,l,o,T,a))}else if(l=e,t.length){const[f,...h]=t,[p,T]=f;e.type==="branch"&&e.nodeKey===p||vt(!1),e.branches.set(T,on(e.branches.get(T),h,e,o,T,a))}return a==null||(i=a.onNodeVisit)===null||i===void 0||i.call(a,l),l},ci=(e,t,n)=>n?(n.branches.delete(t.branchKey),fo(e,n,n.parent)):e===t,fo=(e,t,n)=>n?(t.branches.size===0&&n.branches.delete(t.branchKey),fo(e,n,n.parent)):e===t,ho=e=>e.type==="leaf"?1:Array.from(e.branches.values()).reduce((t,n)=>t+ho(n),0);var li={TreeCache:ii},ui=li.TreeCache,po=Object.freeze({__proto__:null,TreeCache:ui});class fi{constructor(t){var n;P(this,"_maxSize",void 0),P(this,"_size",void 0),P(this,"_head",void 0),P(this,"_tail",void 0),P(this,"_map",void 0),P(this,"_keyMapper",void 0),this._maxSize=t.maxSize,this._size=0,this._head=null,this._tail=null,this._map=new Map,this._keyMapper=(n=t.mapKey)!==null&&n!==void 0?n:o=>o}head(){return this._head}tail(){return this._tail}size(){return this._size}maxSize(){return this._maxSize}has(t){return this._map.has(this._keyMapper(t))}get(t){const n=this._keyMapper(t),o=this._map.get(n);if(!!o)return this.set(t,o.value),o.value}set(t,n){const o=this._keyMapper(t);this._map.get(o)&&this.delete(t);const a=this.head(),i={key:t,right:a,left:null,value:n};a?a.left=i:this._tail=i,this._map.set(o,i),this._head=i,this._size++,this._maybeDeleteLRU()}_maybeDeleteLRU(){this.size()>this.maxSize()&&this.deleteLru()}deleteLru(){const t=this.tail();t&&this.delete(t.key)}delete(t){const n=this._keyMapper(t);if(!this._size||!this._map.has(n))return;const o=I(this._map.get(n)),r=o.right,a=o.left;r&&(r.left=o.left),a&&(a.right=o.right),o===this.head()&&(this._head=r),o===this.tail()&&(this._tail=a),this._map.delete(n),this._size--}clear(){this._size=0,this._head=null,this._tail=null,this._map=new Map}}var di={LRUCache:fi},hi=di.LRUCache,vo=Object.freeze({__proto__:null,LRUCache:hi});const{LRUCache:pi}=vo,{TreeCache:vi}=po;function _i(e,t=n=>n){const n=new pi({maxSize:e}),o=new vi({mapNodeValue:t,onHit:r=>{n.set(r,!0)},onSet:r=>{const a=n.tail();n.set(r,!0),a&&o.size()>e&&o.delete(a.key)}});return o}var mi=_i;const{TreeCache:yi}=po,Rt={equality:"reference",eviction:"none",maxSize:Infinity};function Si({equality:e=Rt.equality,eviction:t=Rt.eviction,maxSize:n=Rt.maxSize}=Rt){const o=Ri(e);return gi(t,n,o)}function Ri(e){switch(e){case"reference":return t=>t;case"value":return t=>St(t)}throw new Error(`Unrecognized equality policy ${e}`)}function gi(e,t,n){switch(e){case"none":return new yi({mapNodeValue:n});case"lru":return mi(I(t),n)}throw new Error(`Unrecognized eviction policy ${e}`)}var bi=Si;function wi(e){return()=>null}var Ti={startPerfBlock:wi};const{CANCELED:Xe,Canceled:Ai,loadableWithError:Ye,loadableWithPromise:Ei,loadableWithValue:rn}=nt,{getNodeLoadable:_o,peekNodeLoadable:Ni,setNodeValue:Vi}=Ue,{saveDependencyMapToStore:Ci}=Ge,{DEFAULT_VALUE:Li,RecoilValueNotReady:$i,getConfigDeletionHandler:Mi,registerNode:mo}=he,{isRecoilValue:Di}=Le,{AbstractRecoilValue:ki}=Le,{setRecoilValueLoadable:Ui}=Ie,{retainedByOptionWithDefault:Ii}=He,{cloneSnapshot:Bi}=ht,{startPerfBlock:Fi}=Ti,Je=[],gt=new Map,Pi=(()=>{let e=0;return()=>e++})();function xi(){return{depValuesDiscoveredSoFarDuringAsyncWork:null,latestLoadable:null,latestExecutionId:null,stateVersion:null}}function Oi(e){const{key:t,get:n,cachePolicy_UNSTABLE:o}=e,r=e.set!=null?e.set:void 0,a=bi(o??{equality:"reference",eviction:"none"}),i=Ii(e.retainedBy_UNSTABLE),l=new Map;let f=0;function h(){return!G("recoil_memory_managament_2020")||f>0}function p(u){return l.has(u)||l.set(u,xi()),I(l.get(u))}function T(u){return f++,u.getState().knownSelectors.add(t),()=>{f--,u.getState().knownSelectors.delete(t),l.delete(u)}}function U(){return Mi(t)!==void 0&&!h()}function F(u,_,v){if(_.state==="loading"){let w=gt.get(v);w==null&&gt.set(v,w=new Set),w.add(u)}}function A(u,_){const v=gt.get(_);if(v!==void 0){for(const w of v)Ui(w,new ki(t),u);gt.delete(_)}}function B(u,_,v){if(_.atomValues.has(v))return I(_.atomValues.get(v));const w=_o(u,_,v),g=u.getState().knownSelectors.has(v);return w.state!=="loading"&&g&&_.atomValues.set(v,w),w}function b(u,_,v,w,g){return _.then(S=>{if(!h())return _e(u,g),Xe;const x=rn(S);return ue(v,j(w),x),L(u,v,new Set(w.keys()),g),C(u,x,g),{__value:S,__key:t}}).catch(S=>{if(!h())return _e(u,g),Xe;if(ne(u,g)&&oe(w,u,g),q(S))return D(u,S,v,w,g);const x=Ye(S);throw ue(v,j(w),x),L(u,v,new Set(w.keys()),g),C(u,x,g),S})}function D(u,_,v,w,g){return _.then(S=>{if(!h())return _e(u,g),Xe;if(S instanceof Ai)return Xe;const{__key:x,__value:X}=S??{};let Y=!0;x!=null&&(v.atomValues.set(x,rn(X)),Y=!1);const[O,z]=H(u,v,g,Y);if(ne(u,g)&&oe(z,u,g),me(O),O.state!=="loading"&&(ue(v,j(z),O),L(u,v,new Set(z.keys()),g),C(u,O,g)),O.state==="hasError")throw O.contents;return O.state==="hasValue"?{__value:O.contents,__key:t}:O.contents}).catch(S=>{if(!h())return _e(u,g),Xe;const x=Ye(S);throw ue(v,j(w),Ye(S)),L(u,v,new Set(w.keys()),g),C(u,x,g),S})}function C(u,_,v){ne(u,v)&&(Z(_,u),A(_,v))}function L(u,_,v,w){var g,S,x,X;if(ne(u,w)||_.version===((g=u.getState())===null||g===void 0||(S=g.currentTree)===null||S===void 0?void 0:S.version)||_.version===((x=u.getState())===null||x===void 0||(X=x.nextTree)===null||X===void 0?void 0:X.version)){var Y,O,z;Ci(new Map([[t,v]]),u,(Y=(O=u.getState())===null||O===void 0||(z=O.nextTree)===null||z===void 0?void 0:z.version)!==null&&Y!==void 0?Y:u.getState().currentTree.version)}}function k(u,_,v,w,g){v.add(w),L(u,_,v,g)}function H(u,_,v,w=!1){const g=Fi(t);let S,x=!1,X;const Y=new Map,O=new Set;L(u,_,O,v);function z(Re){const{key:ye}=Re;k(u,_,O,ye,v);const se=w?_o(u,_,ye):B(u,_,ye);if(me(se),Y.set(ye,se),se.state==="hasValue")return se.contents;throw se.contents}let re=!1;const Me=Re=>(...ye)=>{if(!re)throw new Error("getCallback() should only be called asynchronously after the selector is evalutated.  It can be used for selectors to return objects with callbacks that can obtain the current Recoil state without a subscription.");const se=Bi(u),xe=Re({snapshot:se});if(typeof xe!="function")throw new Error("getCallback() expects a function that returns a function.");return xe(...ye)};try{S=n({get:z,getCallback:Me}),S=Di(S)?z(S):S,re=!0,q(S)?S=b(u,S,_,Y,v).finally(g):g()}catch(Re){S=Re,q(S)?S=D(u,S,_,Y,v).finally(g):(x=!0,g())}return x?X=Ye(S):q(S)?X=Ei(S):X=rn(S),me(X),[X,Y]}function J(u,_){const v=new Set,w=p(u),g=a.get(S=>(typeof S!="string"&&vt(!1),B(u,_,S).contents),{onNodeVisit:S=>{S.type==="branch"&&S.nodeKey!==t&&typeof S.nodeKey=="string"&&v.add(S.nodeKey)}});return g&&L(u,_,v,w.latestExecutionId),g}function j(u){return Array.from(u.entries()).map(([_,v])=>[_,v.contents])}function K(u,_){const v=Pi(),[w,g]=H(u,_,v);return Z(w,u,g,v,_),Se(_,j(g),w),F(u,w,v),w}function le(u,_){const v=J(u,_);if(v!=null)return Z(v,u),v;const w=be(u,_);if(w){const g=w;return F(u,I(g.latestLoadable),I(g.latestExecutionId)),I(g.latestLoadable)}return K(u,_)}function be(u,_){var v;const[,w]=(v=Array.from(l.entries()).find(([,g])=>g.latestLoadable!=null&&g.latestExecutionId!=null&&!ee(u,_)))!==null&&v!==void 0?v:[];return w}const we=new Map;function ee(u,_){var v,w;const g=p(u),S=(v=g.depValuesDiscoveredSoFarDuringAsyncWork)!==null&&v!==void 0?v:new Map,x=Array(((w=we.get(_.version))!==null&&w!==void 0?w:new Map).entries()),X=we.has(_.version)&&x.length===S.size&&x.every(([Y,O])=>S.get(Y)===O);return S==null||_.version===g.stateVersion||X?!1:(we.set(_.version,new Map(S)),Array.from(S).some(([Y,O])=>{const z=B(u,_,Y);return z.contents!==O.contents&&!(O.state==="loading"&&z.state!=="loading")}))}function Z(u,_,v,w,g){const S=p(_);u.state==="loading"?(S.depValuesDiscoveredSoFarDuringAsyncWork=v,S.latestExecutionId=w,S.latestLoadable=u,S.stateVersion=g==null?void 0:g.version):(S.depValuesDiscoveredSoFarDuringAsyncWork=null,S.latestExecutionId=null,S.latestLoadable=null,S.stateVersion=null)}function Se(u,_,v){v.state!=="loading"&&ue(u,_,v)}function oe(u,_,v){const w=p(_);ne(_,v)&&(w.depValuesDiscoveredSoFarDuringAsyncWork=u)}function _e(u,_){ne(u,_)&&l.delete(u)}function ne(u,_){const v=p(u);return _===v.latestExecutionId}function me(u){u.state!=="loading"&&Ne(u.contents)}function Ne(u){}function ue(u,_,v){u.atomValues.set(t,v),a.set(_,v)}function Ve(u){if(Je.includes(t)){const _=`Recoil selector has circular dependencies: ${Je.slice(Je.indexOf(t)).join(" \u2192 ")}`;return Ye(new Error(_))}Je.push(t);try{return u()}finally{Je.pop()}}function $(u,_){return a.get(w=>{typeof w!="string"&&vt(!1);const g=Ni(u,_,w);return g==null?void 0:g.contents})}function fe(u,_){return Ve(()=>le(u,_))}function Ce(u){u.atomValues.delete(t)}return r!=null?mo({key:t,peek:$,get:fe,set:(_,v,w)=>{let g=!1;const S=new Map;function x({key:z}){if(g)throw new Error("Recoil: Async selector sets are not currently supported.");const re=B(_,v,z);if(me(re),re.state==="hasValue")return re.contents;throw re.state==="loading"?new $i(z):re.contents}function X(z,re){if(g)throw new Error("Recoil: Async selector sets are not currently supported.");const Me=typeof re=="function"?re(x(z)):re;Vi(_,v,z.key,Me).forEach((ye,se)=>S.set(se,ye))}function Y(z){X(z,Li)}const O=r({set:X,get:x,reset:Y},w);if(O!==void 0)throw q(O)?new Error("Recoil: Async selector sets are not currently supported."):new Error("Recoil: selector set should be a void function.");return g=!0,S},init:T,invalidate:Ce,shouldDeleteConfigOnRelease:U,dangerouslyAllowMutability:e.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1,retainedBy:i}):mo({key:t,peek:$,get:fe,init:T,invalidate:Ce,shouldDeleteConfigOnRelease:U,dangerouslyAllowMutability:e.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1,retainedBy:i})}var bt=Oi;const{loadableWithError:yo,loadableWithPromise:So,loadableWithValue:Qe}=nt,{DEFAULT_VALUE:Ae,DefaultValue:Fe,getConfigDeletionHandler:Ro,registerNode:zi,setConfigDeletionHandler:Wi}=he,{isRecoilValue:Gi}=Le,{markRecoilValueModified:Hi,setRecoilValue:go,setRecoilValueLoadable:Ki}=Ie,{retainedByOptionWithDefault:qi}=He;function Zi(e){const{key:t,persistence_UNSTABLE:n}=e,o=qi(e.retainedBy_UNSTABLE);let r=0,a=q(e.default)?So(e.default.then(b=>(a=Qe(b),{__key:t,__value:b})).catch(b=>{throw a=yo(b),b})):Qe(e.default),i;const l=new Map;function f(b,D){const C=D.then(L=>{var k,H;return((H=((k=b.getState().nextTree)!==null&&k!==void 0?k:b.getState().currentTree).atomValues.get(t))===null||H===void 0?void 0:H.contents)===C&&go(b,B,L),{__key:t,__value:L}}).catch(L=>{var k,H;throw((H=((k=b.getState().nextTree)!==null&&k!==void 0?k:b.getState().currentTree).atomValues.get(t))===null||H===void 0?void 0:H.contents)===C&&Ki(b,B,yo(L)),L});return C}function h(b,D,C){r++;const L=b.getState().knownAtoms.has(t);if(b.getState().knownAtoms.add(t),a.state==="loading"){const K=()=>{var le;((le=b.getState().nextTree)!==null&&le!==void 0?le:b.getState().currentTree).atomValues.has(t)||Hi(b,B)};a.contents.then(K).catch(K)}let k=Ae,H=null;if(e.effects_UNSTABLE!=null&&!L){let K=!0;const le=ee=>Z=>{if(K){const Se=k instanceof Fe||q(k)?a.state==="hasValue"?a.contents:Ae:k;k=typeof Z=="function"?Z(Se):Z,q(k)&&(k=k.then(oe=>(H={effect:ee,value:oe},oe)))}else{if(q(Z))throw new Error("Setting atoms to async values is not implemented.");typeof Z!="function"&&(H={effect:ee,value:Z}),go(b,B,typeof Z=="function"?Se=>{const oe=Z(Se);return H={effect:ee,value:oe},oe}:Z)}},be=ee=>()=>le(ee)(Ae),we=ee=>Z=>{b.subscribeToTransactions(Se=>{let{currentTree:oe,previousTree:_e}=Se.getState();_e||(_e=oe);const ne=oe.atomValues.get(t);if(ne==null||ne.state==="hasValue"){var me,Ne,ue,Ve;const $=ne!=null?ne.contents:Ae,fe=(me=_e.atomValues.get(t))!==null&&me!==void 0?me:a,Ce=fe.state==="hasValue"?fe.contents:Ae;((Ne=H)===null||Ne===void 0?void 0:Ne.effect)!==ee||((ue=H)===null||ue===void 0?void 0:ue.value)!==$?Z($,Ce):((Ve=H)===null||Ve===void 0?void 0:Ve.effect)===ee&&(H=null)}},t)};for(const ee of(J=e.effects_UNSTABLE)!==null&&J!==void 0?J:[]){var J;const Z=ee({node:B,trigger:C,setSelf:le(ee),resetSelf:be(ee),onSet:we(ee)});Z!=null&&l.set(b,Z)}K=!1}if(!(k instanceof Fe)){var j;const K=q(k)?So(f(b,k)):Qe(k);D.atomValues.set(t,K),(j=b.getState().nextTree)===null||j===void 0||j.atomValues.set(t,K)}return()=>{var K;r--,(K=l.get(b))===null||K===void 0||K(),l.delete(b),b.getState().knownAtoms.delete(t)}}function p(b,D){var C,L,k;return(C=(L=D.atomValues.get(t))!==null&&L!==void 0?L:(k=i)===null||k===void 0?void 0:k[1])!==null&&C!==void 0?C:a}function T(b,D){if(D.atomValues.has(t))return I(D.atomValues.get(t));if(D.nonvalidatedAtoms.has(t)){if(i!=null)return i;if(n==null)return a;const C=D.nonvalidatedAtoms.get(t),L=n.validator(C,Ae);return i=L instanceof Fe?a:Qe(L),i}else return a}function U(){i=void 0}function F(b,D,C){if(D.atomValues.has(t)){const L=I(D.atomValues.get(t));if(L.state==="hasValue"&&C===L.contents)return new Map}else if(!D.nonvalidatedAtoms.has(t)&&C instanceof Fe)return new Map;return i=void 0,new Map().set(t,Qe(C))}function A(){return Ro(t)!==void 0&&r<=0}const B=zi({key:t,peek:p,get:T,set:F,init:h,invalidate:U,shouldDeleteConfigOnRelease:A,dangerouslyAllowMutability:e.dangerouslyAllowMutability,persistence_UNSTABLE:e.persistence_UNSTABLE?{type:e.persistence_UNSTABLE.type,backButton:e.persistence_UNSTABLE.backButton}:void 0,shouldRestoreFromSnapshots:!0,retainedBy:o});return B}function bo(e){const{default:t,...n}=e;return Gi(t)?ji({...n,default:t}):Zi({...n,default:t})}function ji(e){const t=bo({...e,default:Ae,persistence_UNSTABLE:e.persistence_UNSTABLE===void 0?void 0:{...e.persistence_UNSTABLE,validator:o=>o instanceof Fe?o:I(e.persistence_UNSTABLE).validator(o,Ae)},effects_UNSTABLE:e.effects_UNSTABLE}),n=bt({key:`${e.key}__withFallback`,get:({get:o})=>{const r=o(t);return r instanceof Fe?e.default:r},set:({set:o},r)=>o(t,r),dangerouslyAllowMutability:e.dangerouslyAllowMutability});return Wi(n.key,Ro(e.key)),n}var wo=bo;class Xi{constructor(t){var n;P(this,"_map",void 0),P(this,"_keyMapper",void 0),this._map=new Map,this._keyMapper=(n=t==null?void 0:t.mapKey)!==null&&n!==void 0?n:o=>o}size(){return this._map.size}has(t){return this._map.has(this._keyMapper(t))}get(t){return this._map.get(this._keyMapper(t))}set(t,n){this._map.set(this._keyMapper(t),n)}delete(t){this._map.delete(this._keyMapper(t))}clear(){this._map.clear()}}var Yi={MapCache:Xi},Ji=Yi.MapCache,Qi=Object.freeze({__proto__:null,MapCache:Ji});const{LRUCache:ec}=vo,{MapCache:tc}=Qi,wt={equality:"reference",eviction:"none",maxSize:Infinity};function nc({equality:e=wt.equality,eviction:t=wt.eviction,maxSize:n=wt.maxSize}=wt){const o=oc(e);return rc(t,n,o)}function oc(e){switch(e){case"reference":return t=>t;case"value":return t=>St(t)}throw new Error(`Unrecognized equality policy ${e}`)}function rc(e,t,n){switch(e){case"none":return new tc({mapKey:n});case"lru":return new ec({mapKey:n,maxSize:I(t)})}throw new Error(`Unrecognized eviction policy ${e}`)}var To=nc;const{setConfigDeletionHandler:ac}=he;function sc(e){var t;const n=To((t=e.cachePolicyForParams_UNSTABLE)!==null&&t!==void 0?t:{equality:"value",eviction:"none"});return o=>{var r;const a=n.get(o);if(a!=null)return a;const{cachePolicyForParams_UNSTABLE:i,...l}=e,f=wo({...l,key:`${e.key}__${(r=St(o))!==null&&r!==void 0?r:"void"}`,default:typeof e.default=="function"?e.default(o):e.default,retainedBy_UNSTABLE:typeof e.retainedBy_UNSTABLE=="function"?e.retainedBy_UNSTABLE(o):e.retainedBy_UNSTABLE,effects_UNSTABLE:typeof e.effects_UNSTABLE=="function"?e.effects_UNSTABLE(o):e.effects_UNSTABLE});return n.set(o,f),ac(f.key,()=>{n.delete(o)}),f}}var ic=sc;const{setConfigDeletionHandler:cc}=he;let lc=0;function uc(e){var t;const n=To((t=e.cachePolicyForParams_UNSTABLE)!==null&&t!==void 0?t:{equality:"value",eviction:"none"});return o=>{var r;const a=n.get(o);if(a!=null)return a;const i=`${e.key}__selectorFamily/${(r=St(o,{allowFunctions:!0}))!==null&&r!==void 0?r:"void"}/${lc++}`,l=T=>e.get(o)(T),f=e.cachePolicy_UNSTABLE,h=typeof e.retainedBy_UNSTABLE=="function"?e.retainedBy_UNSTABLE(o):e.retainedBy_UNSTABLE;let p;if(e.set!=null){const T=e.set;p=bt({key:i,get:l,set:(F,A)=>T(o)(F,A),cachePolicy_UNSTABLE:f,dangerouslyAllowMutability:e.dangerouslyAllowMutability,retainedBy_UNSTABLE:h})}else p=bt({key:i,get:l,cachePolicy_UNSTABLE:f,dangerouslyAllowMutability:e.dangerouslyAllowMutability,retainedBy_UNSTABLE:h});return n.set(o,p),cc(p.key,()=>{n.delete(o)}),p}}var Ee=uc;const fc=Ee({key:"__constant",get:e=>()=>e,cachePolicyForParams_UNSTABLE:{equality:"reference"}});function dc(e){return fc(e)}var hc=dc;const pc=Ee({key:"__error",get:e=>()=>{throw new Error(e)},cachePolicyForParams_UNSTABLE:{equality:"reference"}});function vc(e){return pc(e)}var _c=vc;function mc(e){return e}var yc=mc;const{loadableWithError:Ao,loadableWithPromise:Eo,loadableWithValue:No}=nt;function Tt(e,t){const n=Array(t.length).fill(void 0),o=Array(t.length).fill(void 0);for(const[r,a]of t.entries())try{n[r]=e(a)}catch(i){o[r]=i}return[n,o]}function Sc(e){return e!=null&&!q(e)}function At(e){return Array.isArray(e)?e:Object.getOwnPropertyNames(e).map(t=>e[t])}function an(e){return e!=null&&typeof e=="object"&&e.hasOwnProperty("__value")?e.__value:e}function sn(e,t){return Array.isArray(e)?t:Object.getOwnPropertyNames(e).reduce((n,o,r)=>({...n,[o]:t[r]}),{})}function Pe(e,t,n){const o=n.map((r,a)=>r==null?No(t[a]):q(r)?Eo(r):Ao(r));return sn(e,o)}function Rc(e,t){return t.map((n,o)=>n===void 0?e[o]:n)}const gc=Ee({key:"__waitForNone",get:e=>({get:t})=>{const n=At(e),[o,r]=Tt(t,n);return Pe(e,o,r)}}),bc=Ee({key:"__waitForAny",get:e=>({get:t})=>{const n=At(e),[o,r]=Tt(t,n);return r.some(a=>!q(a))?Pe(e,o,r):new Promise(a=>{for(const[i,l]of r.entries())q(l)&&l.then(f=>{o[i]=an(f),r[i]=void 0,a(Pe(e,o,r))}).catch(f=>{r[i]=f,a(Pe(e,o,r))})})}}),wc=Ee({key:"__waitForAll",get:e=>({get:t})=>{const n=At(e),[o,r]=Tt(t,n);if(r.every(i=>i==null))return sn(e,o);const a=r.find(Sc);if(a!=null)throw a;return Promise.all(r).then(i=>sn(e,Rc(o,i).map(an)))}}),Tc=Ee({key:"__waitForAllSettled",get:e=>({get:t})=>{const n=At(e),[o,r]=Tt(t,n);return r.every(a=>!q(a))?Pe(e,o,r):Promise.all(r.map((a,i)=>q(a)?a.then(l=>{o[i]=an(l),r[i]=void 0}).catch(l=>{o[i]=void 0,r[i]=l}):null)).then(()=>Pe(e,o,r))}}),Ac=Ee({key:"__noWait",get:e=>({get:t})=>{try{return No(t(e))}catch(n){return q(n)?Eo(n):Ao(n)}}});var Ec={waitForNone:gc,waitForAny:bc,waitForAll:wc,waitForAllSettled:Tc,noWait:Ac};const{batchUpdates:Nc,setBatcher:Vc}=Ft,{DefaultValue:Cc}=he,{RecoilRoot:Lc}=pt,{isRecoilValue:$c}=Le,{retentionZone:Mc}=at,{freshSnapshot:Dc}=ht,{useGotoRecoilSnapshot:kc,useRecoilCallback:Uc,useRecoilSnapshot:Ic,useRecoilState:Bc,useRecoilStateLoadable:Fc,useRecoilTransactionObserver:Pc,useRecoilValue:xc,useRecoilValueLoadable:Oc,useResetRecoilState:zc,useRetain:Wc,useSetRecoilState:Gc,useSetUnvalidatedAtomValues:Hc,useTransactionObservation_DEPRECATED:Kc}=Xs,{noWait:qc,waitForAll:Zc,waitForAllSettled:jc,waitForAny:Xc,waitForNone:Yc}=Ec;var et={DefaultValue:Cc,RecoilRoot:Lc,useRecoilBridgeAcrossReactRoots_UNSTABLE:ai,atom:wo,selector:bt,retentionZone:Mc,atomFamily:ic,selectorFamily:Ee,constSelector:hc,errorSelector:_c,readOnlySelector:yc,useRecoilValue:xc,useRecoilValueLoadable:Oc,useRecoilState:Bc,useRecoilStateLoadable:Fc,useSetRecoilState:Gc,useResetRecoilState:zc,useGetRecoilValueInfo_UNSTABLE:ei,useRetain:Wc,useRecoilCallback:Uc,useGotoRecoilSnapshot:kc,useRecoilSnapshot:Ic,useRecoilTransactionObserver_UNSTABLE:Pc,useTransactionObservation_UNSTABLE:Kc,useSetUnvalidatedAtomValues_UNSTABLE:Hc,noWait:qc,waitForNone:Yc,waitForAny:Xc,waitForAll:Zc,waitForAllSettled:jc,isRecoilValue:$c,batchUpdates:Nc,setBatcher:Vc,snapshot_UNSTABLE:Dc},Jc=et.RecoilRoot,Qc=et.atom,el=et.selector,tl=et.useRecoilValue,nl=et.useRecoilState;export{Jc as RecoilRoot,Qc as atom,el as selector,nl as useRecoilState,tl as useRecoilValue};
